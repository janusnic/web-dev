# web-dev unit_10

Наследование 
============
Наследование — это хорошо зарекомендовавший себя принцип программирования. PHP использует этот принцип в своей объектной модели. Этот принцип будет распространяться на то, каким образом множество классов и объектов относятся друг к другу.

Например, когда вы расширяете класс, дочерний класс наследует все публичные и защищенные методы из родительского класса. До тех пор пока не будут эти методы переопределены, они будут сохранять свою исходную функциональность.

Это полезно для определения и абстрагирования функциональности и позволяет реализовать дополнительную функциональность в похожих объектах без необходимости реализовывать всю общую функциональность.

Пока не используется автозагрузка, классы должны быть объявлены до того, как их будут использовать. Если класс расширяет другой, то родительский класс должен быть объявлен до наследующего класса. Это правило применяется к классам, которые наследуют другие классы или интерфейсы.

Пример наследования

      <?php

      class Foo
      {
          public function printItem($string)
          {
              echo 'Foo: ' . $string . PHP_EOL;
          }
          
          public function printPHP()
          {
              echo 'PHP is great.' . PHP_EOL;
          }
      }

      class Bar extends Foo
      {
          public function printItem($string)
          {
              echo 'Bar: ' . $string . PHP_EOL;
          }
      }

      $foo = new Foo();
      $bar = new Bar();
      $foo->printItem('baz'); // Выведет: 'Foo: baz'
      $foo->printPHP();       // Выведет: 'PHP is great' 
      $bar->printItem('baz'); // Выведет: 'Bar: baz'
      $bar->printPHP();       // Выведет: 'PHP is great'

      ?>


function_exists
---------------
Возвращает TRUE, если указанная функция определена

  bool function_exists ( string $function_name )
Проверяет, есть ли в списке определённых функций, как встроенных, так и пользовательских, функция function_name.

Список параметров 

- function_name - Имя функции, строка.

Возвращаемые значения  

Возвращает TRUE, если function_name существует и является функцией, иначе возвращается FALSE.

Эта функция возвращает FALSE для языковых конструкций, таких как include_once или echo.

Пример использования function_exists()

    <?php
    if (function_exists('imap_open')) {
        echo "IMAP функции доступны.<br />\n";
    } else {
        echo "IMAP функции недоступны.<br />\n";
    }
    ?>

Обратите внимание, что название функции может присутствовать, даже если саму функцию невозможно использовать из-за настроек конфигурации или опций компиляции (например, как для функций image).


crypt
-----
Необратимое хэширование строки

  string crypt ( string $str [, string $salt ] )
crypt() возвращает хэшированную строку, полученную с помощью стандартного алгоритма UNIX, основанного на DES, или другого алгоритма, имеющегося в системе.

Параметр salt вляется необязательным. Однако без salt функция crypt() создает слабый пароль. PHP 5.6 и новее вызывают ошибку E_NOTICE, если не использовать соль. Убедитесь, что используете достаточно сложную соль для лучшей безопасности.

Функция password_hash() использует сложный хэш, генерирует сложную соль и применяет правильно количество раундов хэширования автоматически. password_hash() является простой оберткой над crypt() и совместима с существующими хэшами паролей. Поэтому приветствуется использование password_hash().

Некоторые операционные системы поддерживают несколько алгоритмов хэширования. Иногда стандартный алгоритм, основанный на DES, заменяется алгоритмом на основе MD5. Вид хэширования определяется переданным аргументом salt (соль). До версии PHP 5.3, PHP определял доступные алгоритмы шифрования во время инсталляции, базируясь на системной функции crypt(). Если соль не указана, будет автоматически сгенерирована стандартная случайная двухсимвольная (DES) либо двенадцатисимвольная (MD5) соль, в зависимости от доступности алгоритма MD5 в crypt(). Предопределенная константа CRYPT_SALT_LENGTH позволяет определить максимально доступную длину соли в соответствии с используемыми алгоритмами.

Стандартная функция crypt() на основе DES копирует возвращает соль в качестве первых двух символов возвращаемой строки. Кроме того, она использует только первые восемь символов строки str, поэтому более длинные строки, начинающиеся с тех же восьми символов, сгенерируют один и тот же результат (при использовании одинаковой соли).

На системах, где функция crypt() поддерживает несколько алгоритмов хэширования, следующие константы устанавливаются в 0 или 1 в зависимости от доступности соответствующего алгоритма:

- CRYPT_STD_DES - Стандартное DES-шифрование с двухсимвольной солью из алфавита "./0-9A-Za-z""./0-9A-Za-z". Использование других символов в соли повлечет за собой отказ работы crypt().
- CRYPT_EXT_DES - Расширенное DES-шифрование. "Соль" является девятисимвольной строкой, состоящей из символа подчеркивания, за которым следуют 4 байта счетчика итерации и 4 байта соли. Эти данные будут закодированы в виде печатаемых символов, 6 бит на символ, с меньшим значащим символом указанным первым. Значения от 0 до 63 кодируются как "./0-9A-Za-z". Использование других символов в соли повлечет за собой отказ работы crypt().
- CRYPT_MD5 - MD5-шифрование с 12-символьной солью, начинающейся с $1$
- CRYPT_BLOWFISH - Blowfish-шифрование со следующей солью: "$2a$", "$2x$" или "$2y$", весовой параметр из двух цифр, "$" и 22 цифры из алфавита "./0-9A-Za-z". Использование других символов в соли повлечет за собой возвращение пустой строки. Весовой параметр из двух цифр является двоичным логарифмом счетчика итераций низлежащего хэширующего алгоритма, основанного на Blowfish, и должен быть в диапазоне 04-31, значения вне данного диапазона вызовут отказ crypt(). Версии PHP до 5.3.7 поддерживали только префикс "$2a$" для соли: PHP 5.3.7 добавил новые префиксы для исправлени уязвимостей в реализации Blowfish. Для полного понимания ознакомьтесь с » этим разделом, но если кратко, то разработчики должны использовать "$2y$" вместо "$2a$" начиная с PHP 5.3.7.
- CRYPT_SHA256 - хэш SHA-256 с шестнадцатисимвольной солью, начинающейся с $5$. Если строка с солью начинается с 'rounds=<N>$', число N будет использовано для обозначения количества раундов хэширования, по аналогии с весовым параметром в Blowfish. По умолчанию используемое количество раундов равно 5000, минимально доступно 1000 и максимально 999,999,999. Любой значение вне этого диапазона будет усечено до ближайшего лимита.
- CRYPT_SHA512 - хэш SHA-512 с шестнадцатисимвольной солью, начинающейся с $6$. Если строка с солью начинается с 'rounds=<N>$', число N будет использовано для обозначения количества раундов хэширования, по аналогии с весовым параметром в Blowfish. По умолчанию используемое количество раундов равно 5000, минимально доступно 1000 и максимально 999,999,999. Любой значение вне этого диапазона будет усечено до ближайшего лимита.

Начиная с версии PHP 5.3.0, PHP использует свою собственную реализацию, которая будет использована при отсутствии в системе какого-либо алгоритма.

Список параметров 

- str
Хэшируемая строка.
При использовании алгоритма CRYPT_BLOWFISH, параметр str обрезается до 72 символов.
- salt
Необязательный параметр с солью, на которой будет основано хэширование. Если не указан, поведение определяется по наличию реализованных алгоритмов в системе и может привести к неожиданным результатам.

Возвращаемые значения 

Возвращает хэшированную строку или строку короче 13 символов, гарантированно отличающуюся от соли в случае ошибки.

При валидации паролей должны использоваться функции сравнения строк, устойчивые к атаке по времени, для сравнения вывода функции crypt() с известным хэшом. В PHP 5.6 и новее для этих целей есть функция hash_equals().


Пример использования crypt()

    <?php
    $hashed_password = crypt('mypassword'); // соль будет сгенерирована автоматически

    /* Для проверки пароля в качестве параметра salt следует передавать результат работы
       crypt() целиком во избежание проблем при использовании различных
       алгоритмов (как уже было отмечено выше, стандартный DES-алгоритм
       использует 2-символьную соль, а MD5 - 12-символьную. */
    if (hash_equals($hashed_password, crypt($user_input, $hashed_password))) {
       echo "Пароль верен!";
    }
    ?>
Использование crypt() и htpasswd

    <?php
    // пароль 
    $password = 'mypassword';

    // получение хэша, соль генерируется автоматически
    $hash = crypt($password);
    ?>

Использование crypt() с различными видами хэшей

    <?php
    /* Приведенная соль является только примером. Не используйте эту же соль в вашем коде.
       Вы должны сгенерировать уникальную и правильную соль для каждого пароля.
    */
    if (CRYPT_STD_DES == 1) {
        echo 'Стандартный DES: ' . crypt('rasmuslerdorf', 'rl') . "\n";
    }

    if (CRYPT_EXT_DES == 1) {
        echo 'Расширенный DES: ' . crypt('rasmuslerdorf', '_J9..rasm') . "\n";
    }

    if (CRYPT_MD5 == 1) {
        echo 'MD5:             ' . crypt('rasmuslerdorf', '$1$rasmusle$') . "\n";
    }

    if (CRYPT_BLOWFISH == 1) {
        echo 'Blowfish:        ' . crypt('rasmuslerdorf', '$2a$07$usesomesillystringforsalt$') . "\n";
    }

    if (CRYPT_SHA256 == 1) {
        echo 'SHA-256:         ' . crypt('rasmuslerdorf', '$5$rounds=5000$usesomesillystringforsalt$') . "\n";
    }

    if (CRYPT_SHA512 == 1) {
        echo 'SHA-512:         ' . crypt('rasmuslerdorf', '$6$rounds=5000$usesomesillystringforsalt$') . "\n";
    }
    ?>
Результатом выполнения:

    Стандартный DES: rl.3StKT.4T8M
    Расширенный DES: _J9..rasmBYk8r9AiWNc
    MD5:             $1$rasmusle$rISCgZzpwk3UhDidwXvin0
    Blowfish:        $2a$07$usesomesillystringfore2uDLvp1Ii2e./U9C8sBjqp8I90dH6hi
    SHA-256:         $5$rounds=5000$usesomesillystri$KqJWpanXZHKq2BOB43TSaYhEWsQ1Lr5QNyPCDH/Tp.6
    SHA-512:         $6$rounds=5000$usesomesillystri$D4IrlXatmP7rx3P3InaxBeoomnAihCKRVQP22JZ6EY47Wc6BkroIuUUBOov1i.S5KPgErtP/EN5mcO.ChWQW21

Функция расшифровки отсутствует, так как crypt() использует необратимый алгоритм хэширования.

trigger_error
-------------
Вызывает пользовательскую ошибку/предупреждение/уведомление

  bool trigger_error ( string $error_msg [, int $error_type = E_USER_NOTICE ] )
Используется для вызова пользовательских ошибок, можно использовать в связке с встроенным обработчиком ошибок, а также с пользовательским обработчиком, заданным функцией set_error_handler().

Эта функция может быть полезной, если требуется сгенерировать определенную реакцию на исключение во время выполнения.

Список параметров 

- error_msg
Сообщение, соответствующее этой ошибке. Ограничено 1024 байтами в длину. Символы дальше 1024-го будут обрезаны.

- error_type
Назначенный тип ошибки. Работает только с семейством констант E_USER. По умолчанию E_USER_NOTICE.

Возвращаемые значения 

Функция возвращает FALSE, если задан неправильный error_type, и TRUE в остальных случаях.

Пример использования trigger_error()

    <?php
    if ($divisor == 0) {
        trigger_error("Не могу поделить на ноль", E_USER_ERROR);
    }
    ?>
HTML сущности в error_msg не экранированы. чтобы сообщение можно было отобразить в броузере, преобразуйте его функцией htmlentities().


is_string
---------

Проверяет, является ли переменная строкой

  bool is_string ( mixed $var )
Проверяет, является ли данная переменная строкой.

Список параметров 
- var
Проверяемая переменная.

Возвращаемые значения 
Возвращает TRUE, если var является строкой, и FALSE в противном случае.

Пример использования is_string()

    <?php
    $values = array(false, true, null, 'abc', '23', 23, '23.5', 23.5, '', ' ', '0', 0);
    foreach ($values as $value) {
        echo "is_string(";
        var_export($value);
        echo ") = ";
        echo var_dump(is_string($value));
    }
    ?>
Результат выполнения данного примера:

    is_string(false) = bool(false)
    is_string(true) = bool(false)
    is_string(NULL) = bool(false)
    is_string('abc') = bool(true)
    is_string('23') = bool(true)
    is_string(23) = bool(false)
    is_string('23.5') = bool(true)
    is_string(23.5) = bool(false)
    is_string('') = bool(true)
    is_string(' ') = bool(true)
    is_string('0') = bool(true)
    is_string(0) = bool(false)

is_int
-------
Проверяет, является ли переменная переменной целочисленного типа

  bool is_int ( mixed $var )
Проверяет, является ли тип переменной целочисленным.

Чтобы проверить, что переменная является числом или строкой, содержащей число (как поле ввода в форме, которое всегда является строкой), используйте is_numeric().

Список параметров

- var
Проверяемая переменная.

Возвращаемые значения 

Возвращает TRUE, если var является целым числом, или FALSE в противном случае.

Пример использования is_int()

    <?php
    $values = array(23, "23", 23.5, "23.5", null, true, false);
    foreach ($values as $value) {
        echo "is_int(";
        var_export($value);
        echo ") = ";
        var_dump(is_int($value));
    }
    ?>
Результат выполнения данного примера:

    is_int(23) = bool(true)
    is_int('23') = bool(false)
    is_int(23.5) = bool(false)
    is_int('23.5') = bool(false)
    is_int(NULL) = bool(false)
    is_int(true) = bool(false)
    is_int(false) = bool(false)


sprintf
-------
Возвращает отформатированную строку

  string sprintf ( string $format [, mixed $args [, mixed $... ]] )
Возвращает строку, созданную с использованием строки формата format.

Список параметров 

- format
Строка формата состоит из нуля и более директив: обычных символов (за исключением %), которые копируются напрямую в результирующую строку, и описателей преобразований, каждый из которых заменяется на один из параметров. Это относится как к sprintf(), так и к printf().

Каждый описатель преобразований состоит из знака процента (%), за которым следует один или более дополнительных элементов (в том порядке, в котором они здесь перечислены):

Необязательный описатель знака, указывающий как знак (- или +) будет применен к числу. По умолчанию, используется только знак минус, если число отрицательное. Этот описатель заставляет положительные числа также отображать знак плюс, он был добавлен в PHP 4.3.0.
Необязательный описатель заполнения, который определяет, какой символ будет использоваться для дополнения результата до необходимой длины. Это может быть пробел или 0. По умолчанию используется пробел. Альтернативный символ может быть указан с помощью одиночной кавычки ('). 

Необязательный описатель выравнивания, определяющий выравнивание влево или вправо. По умолчанию выравнивается вправо, - используется для выравнивания влево.
Необязательное число, описатель ширины, определяющий минимальное число символов, которое будет содержать результат этого преобразования.

Необязательный описатель точности, указанный в виде точки ('.'), после которой следует необязательная строка из десятичных чисел, определяющая, сколько десятичных разрядов отображать для чисел с плавающей точкой. При использовании со строками этот описатель выступает в роли обрезающей точки, устанавливающей максимальный лимит символов. Также между точкой и цифрой можно указать символ, используемый при дополнении числа.

Описатель типа, определяющий, как трактовать тип данных аргумента. Допустимые типы:

% - символ процента. Аргумент не используется.
b - аргумент трактуется как целое и выводится в виде двоичного числа.
c - аргумент трактуется как целое и выводится в виде символа с соответствующим кодом ASCII.
d - аргумент трактуется как целое и выводится в виде десятичного числа со знаком.
e - аргумент трактуется как число в в научной нотации (например, 1.2e+2). Описатель точности указывает на количество знаков после запятой, начиная с версии PHP 5.2.1. В более ранних версиях он обозначал количество значащих цифр (на один знак меньше).
E - аналогично %e, но использует заглавную букву (например, 1.2E+2).
f - аргумент трактуется как число с плавающей точкой и также выводится в зависимости от локали.
F - аргумент трактуется как число с плавающей точкой и также выводится, но без зависимости от локали. Доступно, начиная с версии PHP 4.3.10 и PHP 5.0.3.
g - выбирает самую краткую запись из %e и %f.
G - выбирает самую краткую запись из %E и %f.
o - аргумент трактуется как целое и выводится в виде восьмеричного числа.
s - аргумент трактуется как строка.
u - аргумент трактуется как целое и выводится в виде десятичного числа без знака.
x - аргумент трактуется как целое и выводится в виде шестнадцатеричного числа (в нижнем регистре).
X - аргумент трактуется как целое и выводится в виде шестнадцатеричного числа (в верхнем регистре).

Переменные будут преобразованы в соответвующий тип для спецификатора:

- string  s
- integer d, u, c, o, x, X, b
- double  g, G, e, E, f, F

Попытка использовать комбинацию строк и спецификаторов ширины с кодировками, которые требуют более одного байта на символ, может привести к неожиданным результатам.

В строке формата поддерживается нумерация и изменение порядка параметров. Например:

Изменение порядка параметров

    <?php
    $num = 5;
    $location = 'дереве';

    $format = '%d обезьян сидят на %s';
    echo sprintf($format, $num, $location);
    ?>
Этот код выведет "5 обезьян сидят на дереве". Теперь представьте, что строка формата содержится в отдельном файле, который потом будет переведен на другой язык

Изменение порядка параметров

    <?php
    $format = 'На %s сидят %d обезьян';
    echo sprintf($format, $num, $location);
    ?>
Появляется проблема: порядок описателей преобразования не соответствует порядку аргументов. Мы не хотим менять код, и нам нужно указать, какому аргументу соответствует тот или иной описатель преобразования.

Изменение порядка параметров

    <?php
    $format = 'На %2$s сидят %1$d обезьян';
    echo sprintf($format, $num, $location);
    ?>
Нумерация аргументов имеет еще одно применение: она позволяет вывести один и тот же аргумент несколько раз без передачи функции дополнительных параметров.

Изменение порядка параметров

    <?php
    $format = 'На %2$s сидят %1$d обезьян.
               Как здорово, когда на %2$s сидят %1$d обезьян.';
    echo sprintf($format, $num, $location);
    ?>
При изменении порядка параметров описатель позиции n$ должен идти сразу за знаком процента (%) прежде всех остальных описателей, как показано в примере ниже.

Указание дополняющего символа

    <?php
    echo sprintf("%'.9d\n", 123);
    echo sprintf("%'.09d\n", 123);
    ?>
Результат выполнения данного примера:

    ......123
    000000123

Использование описателя позиции и совместно с другими описателями

    <?php
    $format = 'На %2$s сидят %1$04d обезьян';
    echo sprintf($format, $num, $location);
    ?>
Результат выполнения данного примера:

    На дереве сидят 0005 обезьян

Попытка использовать спецификатор позиции, больший чем PHP_INT_MAX, приведет к генерации предупреждения функцией sprintf().

Возвращаемые значения 

Возвращает строку, отформатированную в соответствии со строкой format.

sprintf(): заполнение нулями

    <?php
    $n =  43951789;
    $u = -43951789;
    $c = 65; // ASCII 65 is 'A'

    // заметьте, двойной %% выводится как одинарный '%'
    printf("%%b = '%b'\n", $n); // двоичное представление
    printf("%%c = '%c'\n", $c); // выводит символ ascii, аналогично функции chr()
    printf("%%d = '%d'\n", $n); // обычное целое число
    printf("%%e = '%e'\n", $n); // научная нотация
    printf("%%u = '%u'\n", $n); // беззнаковое целое представление положительного числа
    printf("%%u = '%u'\n", $u); // беззнаковое целое представление отрицательного числа
    printf("%%f = '%f'\n", $n); // представление числа с плавающей точкой
    printf("%%o = '%o'\n", $n); // восьмеричное представление
    printf("%%s = '%s'\n", $n); // строка
    printf("%%x = '%x'\n", $n); // шестнадцатеричное представление (нижний регистр)
    printf("%%X = '%X'\n", $n); // шестнадцатеричное представление (верхний регистр)

    printf("%%+d = '%+d'\n", $n); // описатель знака с положительным целым числом
    printf("%%+d = '%+d'\n", $u); // описатель знака с отрицательным целым числом
    ?>
Результат выполнения данного примера:

    %b = '10100111101010011010101101'
    %c = 'A'
    %d = '43951789'
    %e = '4.39518e+7'
    %u = '43951789'
    %u = '4251015507'
    %f = '43951789.000000'
    %o = '247523255'
    %s = '43951789'
    %x = '29ea6ad'
    %X = '29EA6AD'
    %+d = '+43951789'
    %+d = '-43951789'

printf(): описатели строк

    <?php
    $s = 'monkey';
    $t = 'many monkeys';

    printf("[%s]\n",      $s); // обычный вывод строки
    printf("[%10s]\n",    $s); // выравнивание вправо с пробелами
    printf("[%-10s]\n",   $s); // выравнивание влево с пробелами
    printf("[%010s]\n",   $s); // дополнение нулями также работает со строками
    printf("[%'#10s]\n",  $s); // использование собственного дополняющего символа '#'
    printf("[%10.10s]\n", $t); // выравнивание влево с обрезкой в 10 символов
    ?>
Результат выполнения данного примера:

    [monkey]
    [    monkey]
    [monkey    ]
    [0000monkey]
    [####monkey]
    [many monke]

sprintf(): целые числа, дополненные нулями

    <?php
    $isodate = sprintf("%04d-%02d-%02d", $year, $month, $day);
    ?>

sprintf(): форматирование денежных величин

    <?php
    $money1 = 68.75;
    $money2 = 54.35;
    $money = $money1 + $money2;
    // echo $money выведет "123.1";
    $formatted = sprintf("%01.2f", $money);
    // echo $formatted выведет "123.10"
    ?>

sprintf(): научная нотация

    <?php
    $number = 362525200;

    echo sprintf("%.3e", $number); // выведет 3.625e+8
    ?>

gettype
--------
Возвращает тип переменной

  string gettype ( mixed $var )
Возвращает тип PHP-переменной var. Для проверки типа переменной используйте функции is_*.

Список параметров 
- var
Переменная, у которой проверяется тип.

Возвращаемые значения 
Возможными значениями возвращаемой строки являются:

"boolean"
"integer"
"double" (по историческим причинам в случае типа float возвращается "double", а не просто "float")
"string"
"array"
"object"
"resource"
"NULL"
"unknown type"


Пример использования gettype()

    <?php

    $data = array(1, 1., NULL, new stdClass, 'foo');

    foreach ($data as $value) {
        echo gettype($value), "\n";
    }

    ?>
Результатом выполнения данного примера будет что-то подобное:

    integer
    double
    NULL
    object
    string

settype() - Присваивает переменной новый тип
get_class() - Возвращает имя класса, к которому принадлежит объект
is_array() - Определяет, является ли переменная массивом
is_bool() - Проверяет, является ли переменная булевой
is_callable() - Проверяет, может ли значение переменной быть вызвано в качестве функции
is_float() - Проверяет, является ли переменная числом с плавающей точкой
is_int() - Проверяет, является ли переменная переменной целочисленного типа
is_null() - Проверяет, является ли значение переменной равным NULL
is_numeric() - Проверяет, является ли переменная числом или строкой, содержащей число
is_object() - Проверяет, является ли переменная объектом
is_resource() - Проверяет, является ли переменная ресурсом
is_scalar() - Проверяет, является ли переменная скалярным значением
is_string() - Проверяет, является ли переменная строкой
function_exists() - Возвращает TRUE, если указанная функция определена
method_exists() - Проверяет, существует ли метод в данном классе
add a note add a note


strlen
------
Возвращает длину строки

  int strlen ( string $string )
Возвращает длину строки string.

Список параметров 

- string
Строка (string), для которой измеряется длина.

Возвращаемые значения 
Длина строки string в случае успеха, и 0, если string пуста.

Пример использования strlen()

    <?php
    $str = 'abcdef';
    echo strlen($str); // 6

    $str = ' ab cd ';
    echo strlen($str); // 7
    ?>
Функция strlen() возвратит количество байт, а не число символов в строке.
Функция strlen() возвращает NULL при использовании на массивах, а также выводит ошибку уровня E_WARNING.


mcrypt_create_iv
----------------
Creates an initialization vector (IV) from a random source

  string mcrypt_create_iv ( int $size [, int $source = MCRYPT_DEV_URANDOM ] )
Creates an initialization vector (IV) from a random source.

The IV is only meant to give an alternative seed to the encryption routines. This IV does not need to be secret at all, though it can be desirable. You even can send it along with your ciphertext without losing security.

Список параметров 

- size
The size of the IV.

- source
The source of the IV. The source can be MCRYPT_RAND (system random number generator), MCRYPT_DEV_RANDOM (read data from /dev/random) and MCRYPT_DEV_URANDOM (read data from /dev/urandom). Prior to 5.3.0, MCRYPT_RAND was the only one supported on Windows.

Note that the default value of this parameter was MCRYPT_DEV_RANDOM prior to PHP 5.6.0.

Возвращаемые значения 

Returns the initialization vector, or FALSE on error.

mcrypt_create_iv() Example

    <?php
        $size = mcrypt_get_iv_size(MCRYPT_CAST_256, MCRYPT_MODE_CFB);
        $iv = mcrypt_create_iv($size, MCRYPT_DEV_RANDOM);
    ?>


openssl_random_pseudo_bytes
---------------------------
Generate a pseudo-random string of bytes

string openssl_random_pseudo_bytes ( int $length [, bool &$crypto_strong ] )
Generates a string of pseudo-random bytes, with the number of bytes determined by the length parameter.

It also indicates if a cryptographically strong algorithm was used to produce the pseudo-random bytes, and does this via the optional crypto_strong parameter. It's rare for this to be FALSE, but some systems may be broken or old.

Список параметров 

- length
The length of the desired string of bytes. Must be a positive integer. PHP will try to cast this parameter to a non-null integer to use it.

- crypto_strong
If passed into the function, this will hold a boolean value that determines if the algorithm used was "cryptographically strong", e.g., safe for usage with GPG, passwords, etc. TRUE if it did, otherwise FALSE

Возвращаемые значения 
Returns the generated string of bytes on success, или FALSE в случае возникновения ошибки.

openssl_random_pseudo_bytes() example

    <?php
    for ($i = -1; $i <= 4; $i++) {
        $bytes = openssl_random_pseudo_bytes($i, $cstrong);
        $hex   = bin2hex($bytes);

        echo "Lengths: Bytes: $i and Hex: " . strlen($hex) . PHP_EOL;
        var_dump($hex);
        var_dump($cstrong);
        echo PHP_EOL;
    }
    ?>
Результатом выполнения данного примера будет что-то подобное:

    Lengths: Bytes: -1 and Hex: 0
    string(0) ""
    NULL

    Lengths: Bytes: 0 and Hex: 0
    string(0) ""
    NULL

    Lengths: Bytes: 1 and Hex: 2
    string(2) "42"
    bool(true)

    Lengths: Bytes: 2 and Hex: 4
    string(4) "dc6e"
    bool(true)

    Lengths: Bytes: 3 and Hex: 6
    string(6) "288591"
    bool(true)

    Lengths: Bytes: 4 and Hex: 8
    string(8) "ab86d144"
    bool(true)


is_readable
-----------
Определяет существование файла и доступен ли он для чтения

  bool is_readable ( string $filename )
Возвращает TRUE, если файл существует и доступен для чтения.

Список параметров 

- filename
Путь к файлу.

Возвращаемые значения 

Возвращает TRUE, если файл или директория, указанная в filename существует и доступна для чтения, иначе возвращает FALSE.

is_readable() example

    <?php
    $filename = 'test.txt';
    if (is_readable($filename)) {
        echo 'Файл доступен для чтения';
    } else {
        echo 'Файл недоступен для чтения';
    }
    ?>
Ошибки 
В случае неудачного завершения работы генерируется ошибка уровня E_WARNING.

Не забывайте, что PHP может обращаться к файлам от имени пользователя, от которого запущен веб-сервер (часто 'nobody'). До версии PHP 5.1.5 ограничения безопасного режима не принимались во внимание.

Результаты этой функции кэшируются. Более подробную информацию смотрите в разделе clearstatcache().

Начиная с PHP 5.0.0, эта функция также может быть использована с некоторыми обертками url. Список оберток, поддерживаемых семейством функций stat(), смотрите в Поддерживаемые протоколы и обработчики (wrappers).

Проверка производится с использованием реальных UID/GID вместо эффективных.
Эта функция может возвращать TRUE для директорий. Чтобы отличить файл от директории можно воспользоваться функцией is_dir().

fopen
-----
Открывает файл или URL

  resource fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] )
fopen() закрепляет именованный ресурс, указанный в аргументе filename, за потоком.

Список параметров 

- filename
Если filename передан в форме "scheme://...", он считается URL'ом и PHP проведёт поиск обработчика протокола (также известного как "обертка") для этой схемы. Если ни одна обёртка не закреплена за протоколом, PHP выдаст замечание, чтобы помочь вам отследить потенциальную проблему в вашем скрипте и затем продолжит выполнение, как если бы filename указывал на обыкновенный файл.

Если PHP установлено, что filename указывает на локальный файл, тогда выполняется попытка открыть поток к этому файлу. Файл должен быть доступен PHP, так что вам следует убедиться, что права доступа на файл это разрешают. Если вы включили безопасный режим или open_basedir, то накладываются дальнейшие ограничения.

Если PHP установлено, что filename указывает на зарегистрированный протокол и этот протокол зарегистрирован как сетевой URL, PHP выполняет проверку состояния директивы allow_url_fopen. Если она выключена, PHP выдаст предупреждение и вызов fopen закончится неудачей.

Список поддерживаемых протоколов доступен в разделе Поддерживаемые протоколы и обработчики (wrappers). Некоторые протоколы (обертки) поддерживают контекст и/или опции php.ini. Обратитесь к соответствующей странице с описанием используемого протокола для получения списка опций, которые могут быть установлены. (например, значение php.ini user_agent используется оберткой http).
На платформе Windows, необходимо экранировать все обратные слеши в пути к файлу или использовать прямые слеши.

    <?php
    $handle = fopen("c:\\folder\\resource.txt", "r");
    ?>
- mode
Параметр mode указывает тип доступа, который вы запрашиваете у потока. Он может быть одним из следующих вариантов:

Список возможных режимов для fopen() используя mode

- 'r' Открывает файл только для чтения; помещает указатель в начало файла.
- 'r+'  Открывает файл для чтения и записи; помещает указатель в начало файла.
- 'w' Открывает файл только для записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пробует его создать.
- 'w+'  Открывает файл для чтения и записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пытается его создать.
- 'a' Открывает файл только для записи; помещает указатель в конец файла. Если файл не существует - пытается его создать.
- 'a+'  Открывает файл для чтения и записи; помещает указатель в конец файла. Если файл не существует - пытается его создать.
- 'x' Создаёт и открывает только для записи; помещает указатель в начало файла. Если файл уже существует, вызов fopen() закончится неудачей, вернёт FALSE и выдаст ошибку уровня E_WARNING. Если файл не существует, попытается его создать. Это эквивалентно указанию флагов O_EXCL|O_CREAT для внутреннего системного вызова open(2).
- 'x+'  Создаёт и открывает для чтения и записи; иначе имеет то же поведение что и'x'.
- 'c' Открывает файл только для записи. Если файл не существует, то он создается. Если же файл существует, то он не обрезается (в отличии от 'w'), и вызов к этой функции не вызывает ошибку (также как и в случае с 'x'). Указатель на файл будет установлен на начало файла. Это может быть полезно при желании заблокировать файл (смотри flock()) перед изменением, так как использование - 'w' может обрезать файл еще до того как была получена блокировка (если вы желаете обрезать файл, можно использовать функцию ftruncate() после запроса на блокировку).
- 'c+'  Открывает файл для чтения и записи; иначе имеет то же поведение, что и 'c'.

Разные семейства операционных систем имеют разные соглашения относительно окончания строк. Когда вы пишете текст и хотите вставить разрыв строки, вы должны использовать правильные символы (или символ) для вашей операционной системы. Системы семейства Unix используют \n в качестве символа конца строки, системы семейства Windows используют \r\n в качестве символов окончания строки и системы семейства Macintosh используют \r в качестве символа конца строки.
Если вы используете неверный символ конца строки при редактировании файлов, вы можете обнаружить, что при открытии эти файлы "странно выглядят".
Windows предлагает флаг режима текстовой трансляции ('t'), который автоматически переведёт \n в \r\n во время работы с файлом. И наоборот - вы также можете использовать 'b', чтобы принудительно включить бинарный режим, в котором ваши данные не будут преобразовываться. Чтобы использовать эти режимы, укажите 'b' или 't' последней буквой параметра mode.
Так как установка флага трансляции по умолчанию зависит от SAPI и используемой версии PHP, рекомендуем явно задавать указанный флаг из соображений портируемости. Вы должны использовать режим 't', если вы работаете с текстовым файлом и использовать \n для обозначения конца строки в вашем скрипте, при этом не беспокоясь за читаемость ваших файлов в других приложениях типа "Блокнота". Во всех остальных случаях используйте флаг 'b'.
Если вы явно не укажете флаг 'b' во время работы с бинарными файлами, вы можете столкнуться со странной порчей ваших данных, включая испорченные файлы изображений и странные проблемы с символами \r\n.

Из соображений портируемости, настоятельно рекомендуется всегда использовать флаг 'b' при открытии файлов с помощью fopen().

Кроме того, из соображений портируемости, также настойчиво рекомендуется переписать старый код, который полагается на режим 't', чтобы вместо этого он использовал правильные концы строк и режим 'b'.

- use_include_path
Необязательный третий параметр use_include_path может быть установлен в '1' или TRUE, если вы также хотите провести поиск файла в include_path.

- context
Поддержка контекста была добавлена в PHP 5.0.0. Для описания контекстов смотрите раздел Потоки.
Возвращаемые значения 
Возвращает указатель на файл в случае успешной работы, или FALSE в случае ошибки.

Ошибки 
Если открыть файл не удалось, будет сгенерирована ошибка уровня E_WARNING. Вы можете использовать оператор @ для подавления этой ошибки.

Примеры использования fopen()

    <?php
    $handle = fopen("/home/rasmus/file.txt", "r");
    $handle = fopen("/home/rasmus/file.gif", "wb");
    $handle = fopen("http://www.example.com/", "r");
    $handle = fopen("ftp://user:password@example.com/somefile.txt", "w");
    ?>
При использовании SSL, Microsoft IIS нарушает протокол, закрывая соединение без отправки индикатора close_notify. PHP сообщит об этом как "SSL: Fatal Protocol Error" в тот момент, когда вы достигнете конца данных. Чтобы обойти это, вы должны установить error_reporting на уровень, исключающий E_WARNING. PHP версий 4.3.7 и старше умеет определять, что на стороне сервера находится проблемный IIS при открытии потока с помощью обертки https:// и не выводит предупреждение. Если вы используете fsockopen() для создания ssl:// сокета, вы сами отвечаете за определение и подавление этого предупреждения.
Когда опция safe mode включена, PHP проверяет, имеет ли каталог, с которым вы собираетесь работать, такой же UID (владельца), как и выполняемый скрипт.

Если вы сталкиваетесь с проблемами во время чтения или записи файлов, и вы используете PHP в виде серверного модуля, убедитесь в том, что процесс сервера имеет доступ к используемым вами файлам и директориям.

Эта функция также может выполниться успешно, в случае если filename является директорией. Если вы не уверены является ли filename файлом или директорией, то вам необходимо воспользоваться функцией is_dir(), до вызова fopen().

fclose() - Закрывает открытый дескриптор файла
fgets() - Читает строку из файла
fread() - Бинарно-безопасное чтение файла
fwrite() - Бинарно-безопасная запись в файл
fsockopen() - Открывает соединение с интернет сокетом или доменным сокетом Unix
file() - Читает содержимое файла и помещает его в массив
file_exists() - Проверяет наличие указанного файла или каталога
is_readable() - Определяет существование файла и доступен ли он для чтения
stream_set_timeout() - Устанавливает значение тайм-аута на потоке
popen() - Открывает файловый указатель процесса
stream_context_create() - Создаёт контекст потока
umask() - Изменяет текущую umask

fread
-----
fread — Бинарно-безопасное чтение файла

  string fread ( resource $handle , int $length )
fread() читает до length байт из файлового указателя handle. Чтение останавливается как только было достигнуто одно из следующих условий:

было прочитано length байт
достигнут EOF (конец файла)
стал доступен пакет или произошел таймаут сокета (для сетевых потоков)

если читаемый поток является буферизованным и не представляет собой обычный файл, то за один раз максимум читается количество байт, равное размеру одной порции данных (обычно это 8192), однако, в зависимости от ранее буферизованных данных размер возвращаемых данных может быть больше размера одной порции данных.
Список параметров 

- handle
Указатель (resource) на файл, обычно создаваемый с помощью функции fopen().

- length
length указывает размер прочитанных данных в байтах.

Возвращаемые значения 

Возвращает прочтенную строку или FALSE в случае возникновения ошибки.

Простой пример использования fread()

    <?php
    // получает содержимое файла в строку
    $filename = "/usr/local/something.txt";
    $handle = fopen($filename, "r");
    $contents = fread($handle, filesize($filename));
    fclose($handle);
    ?>
Пример бинарного чтения с помощью fread()

На системах, которые различают бинарные и текстовые файлы (к примеру, Windows), файл должен быть открыт с использованием буквы 'b' в параметре mode функции fopen().
    <?php
    $filename = "c:\\files\\somepic.gif";
    $handle = fopen($filename, "rb");
    $contents = fread($handle, filesize($filename));
    fclose($handle);
    ?>
Примеры удаленного чтения с помощью fread()

При чтении чего-либо отличного от локальных файлов, например потоков, возвращаемых при чтении удаленных файлов или из popen() и fsockopen(), чтение остановится после того, как пакет станет доступным. Это означает, что вы должны собирать данные вместе по кусочкам, как показано на примере ниже.
    <?php
    // Для PHP 5 и выше
    $handle = fopen("http://www.example.com/", "rb");
    $contents = stream_get_contents($handle);
    fclose($handle);
    ?>
    <?php
    $handle = fopen("http://www.example.com/", "rb");
    if (FALSE === $handle) {
        exit("Не удалось открыть поток по url адресу");
    }

    $contents = '';

    while (!feof($handle)) {
        $contents .= fread($handle, 8192);
    }
    fclose($handle);
    ?>

Если вы просто хотите получить содержимое файла в виде строки, используйте file_get_contents(), так как эта функция намного производительнее, чем код описанный выше.

fread() читает начиная с текущей позиции файлового указателя. Используйте функцию ftell() для нахождения текущей позиции указателя и функцию rewind() для перемотки позиции указателя в начало.

fwrite() - Бинарно-безопасная запись в файл
fopen() - Открывает файл или URL
fsockopen() - Открывает соединение с интернет сокетом или доменным сокетом Unix
popen() - Открывает файловый указатель процесса
fgets() - Читает строку из файла
fgetss() - Прочитать строку из файла и отбросить HTML-теги
fscanf() - Обрабатывает данные из файла в соответствии с форматом
file() - Читает содержимое файла и помещает его в массив
fpassthru() - Выводит все оставшиеся данные из файлового указателя
ftell() - Сообщает текущую позицию чтения/записи файла
rewind() - Сбрасывает курсор у файлового указателя

chr
---
chr — Возвращает символ по его коду

  string chr ( int $ascii )
Возвращает строку из одного символа, код которого задан аргументом ascii.

Эта функция дополняет функцию ord().

Список параметров 

- ascii
ASCII-код.

Возвращаемые значения 

Возвращает символ по его коду.

Пример использования chr()

    <?php
    $str = "Эта строка заканчивается на escape: ";
    $str .= chr(27); /* добавляет символ escape в конец $str */

    /* Но обычно лучше использовать такую конструкцию */

    $str = sprintf("The string ends in escape: %c", 27);
    ?>


mt_rand
--------
mt_rand — Генерирует случайное значение методом mt

  int mt_rand ( void )
  int mt_rand ( int $min , int $max )
Многие генераторы случайных чисел в старых библиотеках имеют сомнительные или неизвестные характеристики, а также работают довольно медленно. По умолчанию, PHP использует генератор случайных чисел libc с помощью функции rand(). Функция mt_rand() представляет собой удобную замену этой функции. Она использует генератор случайных чисел с известными характеристиками, основанный на "» Вихре Мерсенна", который генерирует случайные числа в среднем в четыре раза быстрее, чем libc rand().

Вызванная без необязательных параметров min и max, функция mt_rand() возвращает псевдослучайное значение между 0 и mt_getrandmax(). Если вам нужно, например, случайное число между 5 и 15 (включительно), используйте вызов mt_rand(5,15)

Список параметров 

- min
Необязательный параметр: минимальное значение случайного числа (по умолчанию: 0)

- max
Необязательный параметр: максимальное значение случайного числа (по умолчанию: mt_getrandmax())

Возвращаемые значения 

Случайное целое значение между min (или 0) и max (или mt_getrandmax(), включительно), или FALSE в случае, если max меньше min.

Пример использования mt_rand()

    <?php
    echo mt_rand() . "\n";
    echo mt_rand() . "\n";

    echo mt_rand(5, 15);
    ?>
Результатом выполнения данного примера будет что-то подобное:

    1604716014
    1478613278
    6
Данная функция не генерирует криптографически безопасные значения и не должна использоваться в криптографических целях. Если вам требуется криптографически безопасное значение, подумайте об использовании функции openssl_random_pseudo_bytes() вместо данной.

Распределение значений, возвращаемых mt_rand(), отдает предпочтение четным числам на 64-битных сборках PHP, если параметр max больше 2^32. Потому что, если max больше, чем значение, возвращаемое функцией mt_getrandmax(), то вывод генератора случайных чисел округляется в большую сторону.

str_replace
-----------
str_replace — Заменяет все вхождения строки поиска на строку замены

  mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )
Эта функция возвращает строку или массив, в котором все вхождения search в subject заменены на replace.

Если не нужны сложные правила поиска/замены (например, регулярные выражения), использование этой функции предпочтительнее preg_replace().

Список параметров 

Если search и replace - массивы, то str_replace() использует каждое значение из соответствующего массива для поиска и замены в subject. Если в массиве replace меньше элементов, чем в search, в качестве строки замены для оставшихся значений будет использована пустая строка. Если search - массив, а replace - строка, то эта строка замены будет использована для каждого элемента массива search. Обратный случай смысла не имеет.

Если search или replace являются массивами, их элементы будут обработаны от первого к последнему.

- search
Искомое значение, также известное как needle (иголка). Для множества искомых значений можно использовать массив.

- replace
Значение замены, будет использовано для замены искомых значений search. Для множества значений можно использовать массив.

- subject
Строка или массив, в котором производится поиск и замена, также известный как haystack (стог сена).

Если subject является массивом, то поиск с заменой будет осуществляться над каждым элементом subject, а результатом функции также будет являться массив.

- count
Если передан, то будет установлен в количество произведенных замен.

Возвращаемые значения 

Эта функция возвращает строку или массив с замененными значениями.

Примеры использования str_replace()

    <?php
    // присваивает <body text='black'>
    $bodytag = str_replace("%body%", "black", "<body text='%body%'>");

    // присваивает: Hll Wrld f PHP
    $vowels = array("a", "e", "i", "o", "u", "A", "E", "I", "O", "U");
    $onlyconsonants = str_replace($vowels, "", "Hello World of PHP");

    // присваивает: You should eat pizza, beer, and ice cream every day
    $phrase  = "You should eat fruits, vegetables, and fiber every day.";
    $healthy = array("fruits", "vegetables", "fiber");
    $yummy   = array("pizza", "beer", "ice cream");

    $newphrase = str_replace($healthy, $yummy, $phrase);

    // присваивает: 2
    $str = str_replace("ll", "", "good golly miss molly!", $count);
    echo $count;
    ?>
Примеры потенциальных трюков с str_replace()

    <?php
    // Порядок замены
    $str     = "Строка 1\nСтрока 2\rСтрока 3\r\nСтрока 4\n";
    $order   = array("\r\n", "\n", "\r");
    $replace = '<br />';

    // Обрабатывает сначала \r\n для избежания их повторной замены.
    echo $newstr = str_replace($order, $replace, $str);

    // Выводит F, т.к. A заменяется на B, затем B на C, и так далее...
    // В итоге E будет заменено F, так как замена происходит слева направо.
    $search  = array('A', 'B', 'C', 'D', 'E');
    $replace = array('B', 'C', 'D', 'E', 'F');
    $subject = 'A';
    echo str_replace($search, $replace, $subject);

    // Выводит: яблорехкорех орех (по вышеуказанной причине)
    $letters = array('я', 'о');
    $fruit   = array('яблоко', 'орех');
    $text    = 'я о';
    $output  = str_replace($letters, $fruit, $text);
    echo $output;
    ?>

Эта функция безопасна для обработки данных в двоичной форме.

Так как str_replace() осуществляет замену слева направо, то при использовании множественных замен она может заменить ранее вставленное значение на другое. Смотрите также примеры на этой странице.

Эта функция чувствительна к регистру. Используйте str_ireplace() для замены, нечувствительной к регистру.


base64_encode
-------------
base64_encode — Кодирует данные алгоритмом MIME base64

  string base64_encode ( string $data )
Кодирует data алгоритмом base64.

Это кодирование разработано для корректной передачи бинарных данных по протоколам, не поддерживающим 8-битную передачу, например для отправки бинарных файлов в теле письма.

Данные кодированные алгоритмом Base64 увеличиваются в объеме на 33% по сравнению с оригинальными данными.

Список параметров 

- data
Данные для кодирования.

Возвращаемые значения 

Кодированные данные, как строку или FALSE в случае возникновения ошибки.

Пример использования base64_encode()

    <?php
    $str = 'Строка в кодировке UTF-8';
    echo base64_encode($str);
    ?>
Результат выполнения данного примера:

  0KHRgtGA0L7QutCwINCyINC60L7QtNC40YDQvtCy0LrQtSBVVEYtOA==

sscanf
------
sscanf — Разбирает строку в соответствии с заданным форматом

  mixed sscanf ( string $str , string $format [, mixed &$... ] )
Функция sscanf() похожа на функцию printf(), но используется не для вывода, а для ввода данных. sscanf() интерпретирует строку str в соответствии с форматом format, указанным в документации к функцииsprintf().

Любые пробельные символы в строке формата соответствуют любым пробельным символам во входной строке. Это значит, что, например, символ табуляции \t в строке формата соответствует символу пробела во входной строке.

Список параметров 

- str
Обрабатываемая строка (string).

- format
Формат, в соответствии с которым будет интерпретирована строка str, описанный в документации к функции sprintf() со следующими отличиями:

На функцию не влияют настройки локали.
    F, g, G и b не поддерживаются.
    D обозначает десятичное число.
    i обозначает целое число с автоматическим определением системы счисления.
    n обозначает обработанное количество символов на данный момент.

Необязательные переменные, передаваемые по ссылке, которым будут присвоены считанные значения.

Возвращаемые значения 

Если переданы только эти два аргумента, будет возвращен массив. В противном случае, считанные из строки значения будут присвоены переменным, переданным через дополнительные аргументы, и будет возвращено количество присвоенных значений. Дополнительные аргументы должны передаваться по ссылке.

Если ожидается больше подстрок в параметре format, чем доступно в параметре str, то будет возвращено значение -1.

Пример использования sscanf()

    <?php
    // получаем серийный номер
    list($serial) = sscanf("SN/2350001", "SN/%d");
    // и дату изготовления
    $mandate = "January 01 2000";
    list($month, $day, $year) = sscanf($mandate, "%s %d %d");
    echo "Узел $serial был изготовлен: $year-" . substr($month, 0, 3) . "-$day\n";
    ?>
Если переданы необязательные аргументы, значения будут присвоены им, а возвращено будет количество присвоенных значений.

sscanf() - использование необязательных аргументов

      <?php
      // получить имя автора и сформировать запись в формате DocBook
      $auth = "24\tLewis Carroll";
      $n = sscanf($auth, "%d\t%s %s", $id, $first, $last);
      echo "<author id='$id'>
          <firstname>$first</firstname>
          <surname>$last</surname>
      </author>\n";
      ?>


list
----
list — Присваивает переменным из списка значения подобно массиву

  array list ( mixed $var1 [, mixed $... ] )
Подобно array(), это не функция, а языковая конструкция. list() используется для того, чтобы присвоить списку переменных значения за одну операцию.

Список параметров 

- var1
Переменная.

Возвращаемые значения 

Возвращает присвоенный массив.

Примеры использования list()

    <?php

    $info = array('кофе', 'коричневый', 'кофеин');

    // Составить список всех переменных
    list($drink, $color, $power) = $info;
    echo "$drink - $color, а $power делает его особенным.\n";

    // Составить список только некоторых из них
    list($drink, , $power) = $info;
    echo "В $drink есть $power.\n";

    // Или только третья
    list( , , $power) = $info;
    echo "Мне нужен $power!\n";

    // list() не работает со строками
    list($bar) = "abcde";
    var_dump($bar); // NULL
    ?>

Пример использования list()

      <table>
       <tr>
        <th>Имя работника</th>
        <th>Зарплата</th>
       </tr>

      <?php
      $result = $pdo->query("SELECT id, name, salary FROM employees");
      while (list($id, $name, $salary) = $result->fetch(PDO::FETCH_NUM)) {
          echo " <tr>\n" .
                "  <td><a href=\"info.php?id=$id\">$name</a></td>\n" .
                "  <td>$salary</td>\n" .
                " </tr>\n";
      }

      ?>

      </table>

Использование list() с индексами массивов

    <?php

    list($a, list($b, $c)) = array(1, array(2, 3));

    var_dump($a, $b, $c);

    ?>
    int(1)
    int(2)
    int(3)

Использование list() с индексами массива

    <?php

    $info = array('кофе', 'коричневый', 'кофеин');

    list($a[0], $a[1], $a[2]) = $info;

    var_dump($a);

    ?>
Выведет (сравните порядок исходных элементов с порядком, в в котором они были перезаписаны list()):

    array(3) {
      [2]=>
      string(12) "кофеин"
      [1]=>
      string(20) "коричневый"
      [0]=>
      string(8) "кофе"
    }

list() присваивает значения начиная с крайнего правого параметра. Если вы используете простые переменные, можете не беспокоиться об этом. Но если вы используете индексные массивы, вы можете ожидать, что в результате выполнения функции list() вы получите тот же порядок элементов, что и в исходном массиве: слева направо; однако это не так. Они будут присвоены в обратном порядке.

Изменение массива во время выполнения функции list() (например, использование list($a, $b) = $b) приводит к непредсказуемому поведению.
list() работает только с массивами, индексами которых являются числа и нумерация которых начинается с 0.

ord
---
ord — Возвращает ASCII-код символа

  int ord ( string $string )
Возвращает ASCII-код первого символа строки string.

Эта функция дополняет функцию chr().

Список параметров 

- string
Символ.

Возвращаемые значения 

Возвращает ASCII-код в виде целого числа.

Пример использования ord()

      <?php
      $str = "\n";
      if (ord($str) == 10) {
          echo "Первый символ \$str - перевод строки.\n";
      }
      ?>


      <?php
      if (!defined('PASSWORD_DEFAULT')) {
              define('PASSWORD_BCRYPT', 1);
              define('PASSWORD_DEFAULT', PASSWORD_BCRYPT);
      }

          Class Password {

              public function __construct() {}


              /**
               * Hash the password using the specified algorithm
               *
               * @param string $password The password to hash
               * @param int    $algo     The algorithm to use (Defined by PASSWORD_* constants)
               * @param array  $options  The options for the algorithm to use
               *
               * @return string|false The hashed password, or false on error.
               */
              function password_hash($password, $algo, array $options = array()) {
                  if (!function_exists('crypt')) {
                      trigger_error("Crypt must be loaded for password_hash to function", E_USER_WARNING);
                      return null;
                  }
                  if (!is_string($password)) {
                      trigger_error("password_hash(): Password must be a string", E_USER_WARNING);
                      return null;
                  }
                  if (!is_int($algo)) {
                      trigger_error("password_hash() expects parameter 2 to be long, " . gettype($algo) . " given", E_USER_WARNING);
                      return null;
                  }
                  switch ($algo) {
                      case PASSWORD_BCRYPT :
                          // Note that this is a C constant, but not exposed to PHP, so we don't define it here.
                          $cost = 10;
                          if (isset($options['cost'])) {
                              $cost = $options['cost'];
                              if ($cost < 4 || $cost > 31) {
                                  trigger_error(sprintf("password_hash(): Invalid bcrypt cost parameter specified: %d", $cost), E_USER_WARNING);
                                  return null;
                              }
                          }
                          // The length of salt to generate
                          $raw_salt_len = 16;
                          // The length required in the final serialization
                          $required_salt_len = 22;
                          $hash_format = sprintf("$2y$%02d$", $cost);
                          break;
                      default :
                          trigger_error(sprintf("password_hash(): Unknown password hashing algorithm: %s", $algo), E_USER_WARNING);
                          return null;
                  }
                  if (isset($options['salt'])) {
                      switch (gettype($options['salt'])) {
                          case 'NULL' :
                          case 'boolean' :
                          case 'integer' :
                          case 'double' :
                          case 'string' :
                              $salt = (string)$options['salt'];
                              break;
                          case 'object' :
                              if (method_exists($options['salt'], '__tostring')) {
                                  $salt = (string)$options['salt'];
                                  break;
                              }
                          case 'array' :
                          case 'resource' :
                          default :
                              trigger_error('password_hash(): Non-string salt parameter supplied', E_USER_WARNING);
                              return null;
                      }
                      if (strlen($salt) < $required_salt_len) {
                          trigger_error(sprintf("password_hash(): Provided salt is too short: %d expecting %d", strlen($salt), $required_salt_len), E_USER_WARNING);
                          return null;
                      } elseif (0 == preg_match('#^[a-zA-Z0-9./]+$#D', $salt)) {
                          $salt = str_replace('+', '.', base64_encode($salt));
                      }
                  } else {
                      $buffer = '';
                      $buffer_valid = false;
                      if (function_exists('mcrypt_create_iv') && !defined('PHALANGER')) {
                          $buffer = mcrypt_create_iv($raw_salt_len, MCRYPT_DEV_URANDOM);
                          if ($buffer) {
                              $buffer_valid = true;
                          }
                      }
                      if (!$buffer_valid && function_exists('openssl_random_pseudo_bytes')) {
                          $buffer = openssl_random_pseudo_bytes($raw_salt_len);
                          if ($buffer) {
                              $buffer_valid = true;
                          }
                      }
                      if (!$buffer_valid && is_readable('/dev/urandom')) {
                          $f = fopen('/dev/urandom', 'r');
                          $read = strlen($buffer);
                          while ($read < $raw_salt_len) {
                              $buffer .= fread($f, $raw_salt_len - $read);
                              $read = strlen($buffer);
                          }
                          fclose($f);
                          if ($read >= $raw_salt_len) {
                              $buffer_valid = true;
                          }
                      }
                      if (!$buffer_valid || strlen($buffer) < $raw_salt_len) {
                          $bl = strlen($buffer);
                          for ($i = 0; $i < $raw_salt_len; $i++) {
                              if ($i < $bl) {
                                  $buffer[$i] = $buffer[$i] ^ chr(mt_rand(0, 255));
                              } else {
                                  $buffer .= chr(mt_rand(0, 255));
                              }
                          }
                      }
                      $salt = str_replace('+', '.', base64_encode($buffer));
                  }
                  $salt = substr($salt, 0, $required_salt_len);

                  $hash = $hash_format . $salt;

                  $ret = crypt($password, $hash);

                  if (!is_string($ret) || strlen($ret) <= 13) {
                      return false;
                  }

                  return $ret;
              }

              /**
               * Get information about the password hash. Returns an array of the information
               * that was used to generate the password hash.
               *
               * array(
               *    'algo' => 1,
               *    'algoName' => 'bcrypt',
               *    'options' => array(
               *        'cost' => 10,
               *    ),
               * )
               *
               * @param string $hash The password hash to extract info from
               *
               * @return array The array of information about the hash.
               */
              function password_get_info($hash) {
                  $return = array('algo' => 0, 'algoName' => 'unknown', 'options' => array(), );
                  if (substr($hash, 0, 4) == '$2y$' && strlen($hash) == 60) {
                      $return['algo'] = PASSWORD_BCRYPT;
                      $return['algoName'] = 'bcrypt';
                      list($cost) = sscanf($hash, "$2y$%d$");
                      $return['options']['cost'] = $cost;
                  }
                  return $return;
              }

              /**
               * Determine if the password hash needs to be rehashed according to the options provided
               *
               * If the answer is true, after validating the password using password_verify, rehash it.
               *
               * @param string $hash    The hash to test
               * @param int    $algo    The algorithm used for new password hashes
               * @param array  $options The options array passed to password_hash
               *
               * @return boolean True if the password needs to be rehashed.
               */
              function password_needs_rehash($hash, $algo, array $options = array()) {
                  $info = password_get_info($hash);
                  if ($info['algo'] != $algo) {
                      return true;
                  }
                  switch ($algo) {
                      case PASSWORD_BCRYPT :
                          $cost = isset($options['cost']) ? $options['cost'] : 10;
                          if ($cost != $info['options']['cost']) {
                              return true;
                          }
                          break;
                  }
                  return false;
              }

              /**
               * Verify a password against a hash using a timing attack resistant approach
               *
               * @param string $password The password to verify
               * @param string $hash     The hash to verify against
               *
               * @return boolean If the password matches the hash
               */
              public function password_verify($password, $hash) {
                  if (!function_exists('crypt')) {
                      trigger_error("Crypt must be loaded for password_verify to function", E_USER_WARNING);
                      return false;
                  }
                  $ret = crypt($password, $hash);
                  if (!is_string($ret) || strlen($ret) != strlen($hash) || strlen($ret) <= 13) {
                      return false;
                  }

                  $status = 0;
                  for ($i = 0; $i < strlen($ret); $i++) {
                      $status |= (ord($ret[$i]) ^ ord($hash[$i]));
                  }

                  return $status === 0;
              }

          }


      <?php

      include('class.password.php');

      class User extends Password{

          private $db;
        
        function __construct($db){
          parent::__construct();
        
          $this->_db = $db;
        }

        public function is_logged_in(){
          if(isset($_SESSION['loggedin']) && $_SESSION['loggedin'] == true){
            return true;
          }   
        }

        private function get_user_hash($username){  

          try {

            $stmt = $this->_db->prepare('SELECT password FROM blog_members WHERE username = :username');
            $stmt->execute(array('username' => $username));
            
            $row = $stmt->fetch();
            return $row['password'];

          } catch(PDOException $e) {
              echo '<p class="error">'.$e->getMessage().'</p>';
          }
        }

        
        public function login($username,$password){ 

          $hashed = $this->get_user_hash($username);
          
          if($this->password_verify($password,$hashed) == 1){
              
              $_SESSION['loggedin'] = true;
              return true;
          }   
        }
        
          
        public function logout(){
          session_destroy();
        }
        
      }


      ?>


      -- phpMyAdmin SQL Dump
      -- version 4.0.10deb1
      -- http://www.phpmyadmin.net
      --
      -- Host: localhost
      -- Generation Time: Apr 23, 2016 at 11:14 PM
      -- Server version: 5.5.47-0ubuntu0.14.04.1
      -- PHP Version: 5.5.9-1ubuntu4.14

      SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
      SET time_zone = "+00:00";


      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
      /*!40101 SET NAMES utf8 */;

      --
      -- Database: `webdev`
      --

      -- --------------------------------------------------------

      --
      -- Table structure for table `blog_cats`
      --

      CREATE TABLE IF NOT EXISTS `blog_cats` (
        `catID` int(11) unsigned NOT NULL AUTO_INCREMENT,
        `catTitle` varchar(255) DEFAULT NULL,
        `catSlug` varchar(255) DEFAULT NULL,
        PRIMARY KEY (`catID`)
      ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ;

      --
      -- Dumping data for table `blog_cats`
      --

      INSERT INTO `blog_cats` (`catID`, `catTitle`, `catSlug`) VALUES
      (1, 'General', 'general'),
      (2, 'Development', 'development'),
      (5, 'Misc', 'misc'),
      (4, 'Testing', 'testing');

      -- --------------------------------------------------------

      --
      -- Table structure for table `blog_members`
      --

      CREATE TABLE IF NOT EXISTS `blog_members` (
        `memberID` int(11) unsigned NOT NULL AUTO_INCREMENT,
        `username` varchar(255) DEFAULT NULL,
        `password` varchar(255) DEFAULT NULL,
        `email` varchar(255) DEFAULT NULL,
        PRIMARY KEY (`memberID`)
      ) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

      --
      -- Dumping data for table `blog_members`
      --

      INSERT INTO `blog_members` (`memberID`, `username`, `password`, `email`) VALUES
      (1, 'Demo', '$2a$12$TF8u1maUr5kADc42g1FB0ONJDEtt24ue.UTIuP13gij5AHsg5f5s2', 'demo@demo.com'),
      (2, 'root', '$2y$10$uzqfHAk5Ke6UXVEL8V5OauXp.2rHded70BjGAi4UsL1/In7mrwSwy', 'root@ex.ua');

      -- --------------------------------------------------------

      --
      -- Table structure for table `blog_posts`
      --

      CREATE TABLE IF NOT EXISTS `blog_posts` (
        `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
        `title` varchar(255) DEFAULT NULL,
        `description` text,
        `content` text,
        `created` datetime DEFAULT NULL,
        PRIMARY KEY (`id`)
      ) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=8 ;

      --
      -- Dumping data for table `blog_posts`
      --

      INSERT INTO `blog_posts` (`id`, `title`, `description`, `content`, `created`) VALUES
      (1, 'Bendless Love', '<p>That''s right, baby. I ain''t your loverboy Flexo, the guy you love so much. You even love anyone pretending to be him! Interesting. No, wait, the other thing: tedious. Hey, guess what you''re accessories to. The alien mothership is in orbit here. If we can hit that bullseye, the rest of the dominoes will fall like a house of cards. Checkmate.</p>', '<h2>The Mutants Are Revolting</h2>\r\n<p>We don''t have a brig. And until then, I can never die? We need rest. The spirit is willing, but the flesh is spongy and bruised. And yet you haven''t said what I told you to say! How can any of us trust you?</p>\r\n<ul>\r\n<li>Oh, but you can. But you may have to metaphorically make a deal with the devil. And by "devil", I mean Robot Devil. And by "metaphorically", I mean get your coat.</li>\r\n<li>Bender?! You stole the atom.</li>\r\n<li>I was having the most wonderful dream. Except you were there, and you were there, and you were there!</li>\r\n</ul>\r\n<h3>The Series Has Landed</h3>\r\n<p>Fry! Stay back! He''s too powerful! No. We''re on the top. Fry, you can''t just sit here in the dark listening to classical music.</p>\r\n<h4>Future Stock</h4>\r\n<p>Does anybody else feel jealous and aroused and worried? We''re also Santa Claus! You''re going back for the Countess, aren''t you? Well, let''s just dump it in the sewer and say we delivered it.</p>\r\n<ol>\r\n<li>Spare me your space age technobabble, Attila the Hun!</li>\r\n<li>You guys realize you live in a sewer, right?</li>\r\n<li>I guess if you want children beaten, you have to do it yourself.</li>\r\n<li>Yeah. Give a little credit to our public schools.</li>\r\n</ol>\r\n<h5>The Why of Fry</h5>\r\n<p>Who are you, my warranty?! Shinier than yours, meatbag. Dr. Zoidberg, that doesn''t make sense. But, okay! Yes, except the Dave Matthews Band doesn''t rock.</p>', '2016-01-29 00:00:00'),
      (2, 'That Darn Katz!', '<p>Wow! A superpowers drug you can just rub onto your skin? You''d think it would be something you''d have to freebase. Fry, you can''t just sit here in the dark listening to classical music. And yet you haven''t said what I told you to say! How can any of us trust you?</p>', '<h2>Xmas Story</h2>\r\n<p>It must be wonderful. Does anybody else feel jealous and aroused and worried? Is today''s hectic lifestyle making you tense and impatient? Soothe us with sweet lies. That''s right, baby. I ain''t your loverboy Flexo, the guy you love so much. You even love anyone pretending to be him!</p>\r\n<ul>\r\n<li>Goodbye, friends. I never thought I''d die like this. But I always really hoped.</li>\r\n<li>They''re like sex, except I''m having them!</li>\r\n<li>Come, Comrade Bender! We must take to the streets!</li>\r\n</ul>\r\n<h3>Anthology of Interest I</h3>\r\n<p>Hey, whatcha watching? They''re like sex, except I''m having them! Well I''da done better, but it''s plum hard pleading a case while awaiting trial for that there incompetence. Yes, except the Dave Matthews Band doesn''t rock. I suppose I could part with ''one'' and still be feared&hellip;</p>\r\n<h4>Teenage Mutant Leela''s Hurdles</h4>\r\n<p>Oh, but you can. But you may have to metaphorically make a deal with the devil. And by "devil", I mean Robot Devil. And by "metaphorically", I mean get your coat. Please, Don-Bot&hellip; look into your hard drive, and open your mercy file! It''s a T. It goes "tuh". I guess if you want children beaten, you have to do it yourself.</p>\r\n<ol>\r\n<li>Spare me your space age technobabble, Attila the Hun!</li>\r\n<li>Well, thanks to the Internet, I''m now bored with sex. Is there a place on the web that panders to my lust for violence?</li>\r\n</ol>\r\n<h5>The Farnsworth Parabox</h5>\r\n<p>Wow! A superpowers drug you can just rub onto your skin? You''d think it would be something you''d have to freebase. We need rest. The spirit is willing, but the flesh is spongy and bruised. It must be wonderful.</p>', '2016-02-05 23:10:35'),
      (3, 'How Hermes Requisitioned His Groove Back', '<p>You''re going back for the Countess, aren''t you? Wow! A superpowers drug you can just rub onto your skin? You''d think it would be something you''d have to freebase. Now Fry, it''s been a few years since medical school, so remind me. Disemboweling in your species: fatal or non-fatal? I don''t want to be rescued. Leela, are you alright? You got wanged on the head.</p>', '<h2>The Luck of the Fryrish</h2>\r\n<p>Professor, make a woman out of me. I am the man with no name, Zapp Brannigan! Good man. Nixon''s pro-war and pro-family. The alien mothership is in orbit here. If we can hit that bullseye, the rest of the dominoes will fall like a house of cards. Checkmate. Fry, you can''t just sit here in the dark listening to classical music.</p>\r\n<ul>\r\n<li>Who are those horrible orange men?</li>\r\n<li>Is today''s hectic lifestyle making you tense and impatient?</li>\r\n</ul>\r\n<h3>Lethal Inspection</h3>\r\n<p>Oh, but you can. But you may have to metaphorically make a deal with the devil. And by "devil", I mean Robot Devil. And by "metaphorically", I mean get your coat. No. We''re on the top. Does anybody else feel jealous and aroused and worried? Well I''da done better, but it''s plum hard pleading a case while awaiting trial for that there incompetence. It must be wonderful.</p>\r\n<h4>Where No Fan Has Gone Before</h4>\r\n<p>Who are those horrible orange men? Bender, we''re trying our best. Please, Don-Bot&hellip; look into your hard drive, and open your mercy file! Wow! A superpowers drug you can just rub onto your skin? You''d think it would be something you''d have to freebase. WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT! Look, last night was a mistake.</p>\r\n<ol>\r\n<li>I''m sorry, guys. I never meant to hurt you. Just to destroy everything you ever believed in.</li>\r\n<li>Stop it, stop it. It''s fine. I will ''destroy'' you!</li>\r\n<li>You guys realize you live in a sewer, right?</li>\r\n</ol>\r\n<h5>Fear of a Bot Planet</h5>\r\n<p>Why yes! Thanks for noticing. Hey, guess what you''re accessories to. Yes, except the Dave Matthews Band doesn''t rock. Take me to your leader! Daddy Bender, we''re hungry.</p>', '2016-03-05 23:20:24'),
      (6, 'The Cyber House Rules', '<p>You guys realize you live in a sewer, right? Uh, is the puppy mechanical in any way? Come, Comrade Bender! We must take to the streets! I daresay that Fry has discovered the smelliest object in the known universe! Good news, everyone! There''s a report on TV with some very bad news!</p>', '<h2>The Luck of the Fryrish</h2>\r\n<p>Professor, make a woman out of me. I am the man with no name, Zapp Brannigan! Good man. Nixon''s pro-war and pro-family. The alien mothership is in orbit here. If we can hit that bullseye, the rest of the dominoes will fall like a house of cards. Checkmate. Fry, you can''t just sit here in the dark listening to classical music.</p>\r\n<ul>\r\n<li>Who are those horrible orange men?</li>\r\n<li>Is today''s hectic lifestyle making you tense and impatient?</li>\r\n</ul>\r\n<h3>Lethal Inspection</h3>\r\n<p>Oh, but you can. But you may have to metaphorically make a deal with the devil. And by "devil", I mean Robot Devil. And by "metaphorically", I mean get your coat. No. We''re on the top. Does anybody else feel jealous and aroused and worried? Well I''da done better, but it''s plum hard pleading a case while awaiting trial for that there incompetence. It must be wonderful.</p>\r\n<h4>Where No Fan Has Gone Before</h4>\r\n<p>Who are those horrible orange men? Bender, we''re trying our best. Please, Don-Bot&hellip; look into your hard drive, and open your mercy file! Wow! A superpowers drug you can just rub onto your skin? You''d think it would be something you''d have to freebase. WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT! Look, last night was a mistake.</p>\r\n<ol>\r\n<li>I''m sorry, guys. I never meant to hurt you. Just to destroy everything you ever believed in.</li>\r\n<li>Stop it, stop it. It''s fine. I will ''destroy'' you!</li>\r\n<li>You guys realize you live in a sewer, right?</li>\r\n</ol>\r\n<h5>Fear of a Bot Planet</h5>\r\n<p>Why yes! Thanks for noticing. Hey, guess what you''re accessories to. Yes, except the Dave Matthews Band doesn''t rock. Take me to your leader! Daddy Bender, we''re hungry.</p>', '2016-04-06 08:28:35'),
      (7, 'parameter number first', 'parameter number', 'parameter number', '2016-04-15 20:18:24');

      -- --------------------------------------------------------

      --
      -- Table structure for table `blog_post_cats`
      --

      CREATE TABLE IF NOT EXISTS `blog_post_cats` (
        `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
        `postID` int(11) DEFAULT NULL,
        `catID` int(11) DEFAULT NULL,
        PRIMARY KEY (`id`)
      ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=26 ;

      --
      -- Dumping data for table `blog_post_cats`
      --

      INSERT INTO `blog_post_cats` (`id`, `postID`, `catID`) VALUES
      (25, 2, 5),
      (21, 6, 4),
      (24, 2, 1),
      (4, 3, 2),
      (20, 6, 1),
      (16, 1, 2);

      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;

Category

      <?php
      //include config
      require_once __DIR__.'/../bootstrap/app.php';
      require_once __DIR__.'/../resources/views/layouts/header.php';

      //if not logged in redirect to login page
      if(!$user->is_logged_in()){ header('Location: login.php'); }

      //show message from add / edit page
      if(isset($_GET['delcat'])){ 

        $stmt = $db->prepare('DELETE FROM blog_cats WHERE catID = :catID') ;
        $stmt->execute(array(':catID' => $_GET['delcat']));

        header('Location: categories.php?action=deleted');
        exit;
      } 

      ?>
        <script language="JavaScript" type="text/javascript">
        function delcat(id, title)
        {
          if (confirm("Are you sure you want to delete '" + title + "'"))
          {
            window.location.href = 'categories.php?delcat=' + id;
          }
        }
        </script>

      <main>
          <?php require_once __DIR__.'/../resources/views/layouts/nav_admin.php';?>    

          <section class="row border-top border-bottom">
             <article class="content col-8">

        <?php 
        //show message from add / edit page
        if(isset($_GET['action'])){ 
          echo '<h3>Category '.$_GET['action'].'.</h3>'; 
        } 
        ?>

        <table>
        <tr>
          <th>Title</th>
          <th>Action</th>
        </tr>
        <?php
          try {

            $stmt = $db->query('SELECT catID, catTitle, catSlug FROM blog_cats ORDER BY catTitle DESC');
            while($row = $stmt->fetch()){
              
              echo '<tr>';
              echo '<td>'.$row['catTitle'].'</td>';
              ?>

              <td>
                <a href="edit-category.php?id=<?php echo $row['catID'];?>">Edit</a> | 
                <a href="javascript:delcat('<?php echo $row['catID'];?>','<?php echo $row['catSlug'];?>')">Delete</a>
              </td>
              
              <?php 
              echo '</tr>';

            }

          } catch(PDOException $e) {
              echo $e->getMessage();
          }
        ?>
        </table>

        <p><a href='add-category.php'>Add Category</a></p>

      </article>
      </section>
      </main>
      <?php require_once __DIR__.'/../resources/views/layouts/footer.php'; ?>

add-category.php

      <?php //include config
      require_once __DIR__.'/../bootstrap/app.php';
      require_once __DIR__.'/../resources/views/layouts/header.php';

      //if not logged in redirect to login page
      if(!$user->is_logged_in()){ header('Location: login.php'); }
      ?>


      <main>
          <?php require_once __DIR__.'/../resources/views/layouts/nav_admin.php';?>    

          <section class="row border-top border-bottom">
             <article class="content col-8">
        <p><a href="categories.php">Categories Index</a></p>

        <h2>Add Category</h2>

        <?php

        //if form has been submitted process it
        if(isset($_POST['submit'])){

          $_POST = array_map( 'stripslashes', $_POST );

          //collect form data
          extract($_POST);

          //very basic validation
          if($catTitle ==''){
            $error[] = 'Please enter the Category.';
          }

          if(!isset($error)){

            try {

              $catSlug = slug($catTitle);

              //insert into database
              $stmt = $db->prepare('INSERT INTO blog_cats (catTitle,catSlug) VALUES (:catTitle, :catSlug)') ;
              $stmt->execute(array(
                ':catTitle' => $catTitle,
                ':catSlug' => $catSlug
              ));

              //redirect to index page
              header('Location: categories.php?action=added');
              exit;

            } catch(PDOException $e) {
                echo $e->getMessage();
            }

          }

        }

        //check for any errors
        if(isset($error)){
          foreach($error as $error){
            echo '<p class="error">'.$error.'</p>';
          }
        }
        ?>

        <form action='' method='post'>

          <p><label>Title</label><br />
          <input type='text' name='catTitle' value='<?php if(isset($error)){ echo $_POST['catTitle'];}?>'></p>

          <p><input type='submit' name='submit' value='Submit'></p>

        </form>

      </article>
      </section>
      </main>
      <?php require_once __DIR__.'/../resources/views/layouts/footer.php'; ?>

edit-category.php

    <?php //include config
    require_once __DIR__.'/../bootstrap/app.php';
    require_once __DIR__.'/../resources/views/layouts/header.php';


    //if not logged in redirect to login page
    if(!$user->is_logged_in()){ header('Location: login.php'); }
    ?>
    <main>
        <?php require_once __DIR__.'/../resources/views/layouts/nav_admin.php';?>    

        <section class="row border-top border-bottom">
           <article class="content col-8">
      <p><a href="categories.php">Categories Index</a></p>

      <h2>Edit Category</h2>


      <?php

      //if form has been submitted process it
      if(isset($_POST['submit'])){

        $_POST = array_map( 'stripslashes', $_POST );

        //collect form data
        extract($_POST);

        //very basic validation
        if($catID ==''){
          $error[] = 'This post is missing a valid id!.';
        }

        if($catTitle ==''){
          $error[] = 'Please enter the title.';
        }

        if(!isset($error)){

          try {

            $catSlug = slug($catTitle);

            //insert into database
            $stmt = $db->prepare('UPDATE blog_cats SET catTitle = :catTitle, catSlug = :catSlug WHERE catID = :catID') ;
            $stmt->execute(array(
              ':catTitle' => $catTitle,
              ':catSlug' => $catSlug,
              ':catID' => $catID
            ));

            //redirect to index page
            header('Location: categories.php?action=updated');
            exit;

          } catch(PDOException $e) {
              echo $e->getMessage();
          }

        }

      }

      ?>


      <?php
      //check for any errors
      if(isset($error)){
        foreach($error as $error){
          echo $error.'<br />';
        }
      }

        try {

          $stmt = $db->prepare('SELECT catID, catTitle FROM blog_cats WHERE catID = :catID') ;
          $stmt->execute(array(':catID' => $_GET['id']));
          $row = $stmt->fetch(); 

        } catch(PDOException $e) {
            echo $e->getMessage();
        }

      ?>

      <form action='' method='post'>
        <input type='hidden' name='catID' value='<?php echo $row['catID'];?>'>

        <p><label>Title</label><br />
        <input type='text' name='catTitle' value='<?php echo $row['catTitle'];?>'></p>

        <p><input type='submit' name='submit' value='Update'></p>

      </form>

    </article>
    </section>
    </main>
    <?php require_once __DIR__.'/../resources/views/layouts/footer.php'; ?>
