# web-dev unit_14

ШАБЛОНИЗАТОР BLADE
==================

ШАБЛОНЫ BLADE
-------------

Blade является дефолтным шаблонизатором Laravel (с версии Laravel 2 2011 года). Синтаксис частично позаимствован из шаблонизатора ASP.net Razor и позволяет оформлять шаблоны довольно опрятно. Но синтаксис - всего лишь малая часть, основное преимущество Блейд над чистым PHP - возможность легко переиспользовать шаблоны и разделять шаблон на составляющие.

Blade является простым, но мощным шаблонизатором, который поставляется вместе с Laravel. В отличие от других шаблонных движков, Blade не запрещает использовать PHP код внутри шшаблонов. Все шаблоны Blade компилируются в простой PHP код и кешируются до следующих изменений, что означает - Blade не добавляет накладных расходов в приложение. Два основных преимущества Блейд:наследование и секции.
Все шаблоны Blade должны иметь расширение .blade.php.

Создание шаблона Blade
-----------------------
            <!-- Stored in resources/views/layouts/master.blade.php -->

            <html>
                <head>
                    <title>App Name - @yield('title')</title>
                </head>
                <body>
                    @section('sidebar')
                        Это - главный сайдбар.
                    @show

                    <div class="container">
                        @yield('content')
                    </div>
                </body>
            </html>
Использование шаблона Blade
---------------------------
        @extends('layouts.master')

        @section('title', 'Заголовок страницы')

        @section('sidebar')
            @parent

            <p>Этот элемент будет добавлен к главному сайдбару.</p>
        @stop

        @section('content')
            <p>Это - содержимое страницы.</p>
        @stop

Заметьте, что шаблоны, которые расширяют другой Blade-шаблон с помощью extend, просто перекрывают секции последнего. Старое (перекрытое) содержимое может быть выведено директивой @parent, что позволяет добавлять содержимое в такие секции, как боковая панель или «подвал».

Иногда - например, когда вы не уверены, что секция была определена - вам может понадобиться указать значение по умолчанию для директивы @yield. Вы можете передать его вторым аргументом:

        <div class="container">
            @yield('content', 'Default Content')
        </div>


ДРУГИЕ ДИРЕКТИВЫ BLADE
----------------------
Вывод переменной
----------------
Привет, {{ $name }}.

Текущее время эпохи UNIX: {{ time() }}.

Вывод переменной с проверкой на существование
---------------------------------------------
Иногда вам нужно вывести переменную, которая может быть определена, а может быть нет. Например:

{{ isset($name) ? $name : 'Default' }}

Но вам не обязательно писать тернарный оператор, Blade позволяет записать это короче:

{{ $name or 'Default' }}

Вывод текста с фигурными скобками
---------------------------------
Если вам нужно вывести текст с фигурными скобками - управляющими символами Blade - вы можете поставить префикс @:

@{{ Этот текст не будет обрабатываться шаблонизатором Blade }}

По умолчанию весь выводимый контент экранируется, т.е. все элементы и сущности HTML показываются как есть, вместо того, чтобы обрабатываться браузером. Если вы не хотите, что бы данные экранировались, используйте следующий синтаксис:

Hello, {!! $name !!}.

Будьте осторожны с выводом контента, который получен от пользователей. Всегда используйте двойные фигурные скобки для экранирования возможных элементов и сущностей HTML.

Директива If
-------------
        @if (count($records) === 1)
            Здесь есть одна запись!
        @elseif (count($records) > 1)
            Здесь есть много записей!
        @else
            Здесь нет записей!
        @endif

        @unless (Auth::check())
            Вы не вошли в систему.
        @endunless

Циклы
------
        @for ($i = 0; $i < 10; $i++)
            Текущее значение: {{ $i }}
        @endfor

        @foreach ($users as $user)
            <p>Это пользователь{{ $user->id }}</p>
        @endforeach

        @forelse($users as $user)
              <li>{{ $user->name }}</li>
        @empty
              <p>No users</p>
        @endforelse

        @while (true)
            <p>Это будет длиться вечно.</p>
        @endwhile

Подшаблоны
----------
    @include('view.name')

Вы также можете передать массив переменных во включаемый шаблон:

    @include('view.name', ['some'=>'data'])

Перезапись секций
-----------------
Для полной перезаписи секции можно использовать директиву overwrite:

        @extends('list.item.container')

        @section('list.item.content')
            <p>Это - элемент типа {{ $item->type }}</p>
        @overwrite

Строки файлов локализации
-------------------------
        @lang('language.line')

        @choice('language.line', 1);
Комментарии
------------
        {{-- Этот комментарий не будет выведен в HTML коде страницы --}}


Пример:
------

        @if ($orders->count())
            <ul>
                @foreach($orders as $order)
                    <li>{{ $order->title }}</li>
                @endforeach
            </ul>
        @endif


Управление ресурсами страниц
============================

Регистрация ресурсов
--------------------
Класс Asset предоставляет простой путь к управлению использования CSS и JavaScript в вашем приложении. Для подключения необходимого ресурса просто вызовите метод add класса Asset.

Регистрация ресурса:
--------------------
        Asset::add('jquery', 'js/jquery.js');
Метод add принимает три параметра. Первый - это имя ресурса, второй - путь к ресурсу относительно директории public, третий параметр представляет собой список зависимостей ресурса (мы вернемся к этому позднее). Заметьте, что нет необходимости указывать методу тип регистрируемого ресурса. Метод add использует раширение файла для регистрации.


Вставка ресурса
---------------
Когда вы готовы поключить зарегистрированный ресурс в представление, просто используйте методы styles или scripts:

Вставка ресурса в представление:

        <head>
            <?php echo Asset::styles(); ?>
            <?php echo Asset::scripts(); ?>
        </head>

Зависимости ресурсов
--------------------
Иногда может понадобиться установить зависимости ресурсов, т.е. порядок включения их на страницу. Такое имеет место, когда какой-то javascript не может быть загружен раньше другого, то же самое может быть и с css стилями. И здесь нет ничего проще в Laravel! Вы просто указываете третий параметр в add методе для объявления зависимости:

Регистрация пакета, имеющего зависимости:
-----------------------------------------
        Asset::add('jquery-ui', 'js/jquery-ui.js', 'jquery');
В этом примере, вы определяете jquery-ui ресурс, который зависит от ресурса jquery. Теперь, при вставке на страницу, ресурс jquery будет всегда объявлен раньше jquery-ui, что позволит избежать ошибок. Все это хорошо, но что делать, если есть целая цепочка зависимостей? как их зарегистрировать? Да нет проблем:

Регистрация ресурса с множественными зависимостями:

        Asset::add('jquery-ui', 'js/jquery-ui.js', array('first', 'second'));

asset()
--------

        $url = asset('img/photo.jpg');



HTTP-КОНТРОЛЛЕРЫ
================

Вместо того, чтобы писать логику обработки запросов в файле routes.php, вы можете организовать её, используя классы Controller, которые позволяют группировать связанные обработчики запросов в отдельные классы.

Контроллеры обычно хранятся в папке app/Http/Controllers.


ПРОСТЕЙШИЕ КОНТРОЛЛЕРЫ
----------------------
Вот пример простейшего класса контроллера:

        <?php namespace App\Http\Controllers;
        // Все контроллеры должны наследовать базовый класс контроллера.
        use App\Http\Controllers\Controller;

        class GreetingController extends Controller {

            /**
             * @return Response
             */
            public function index()
            {
                return view('hello.greeting', ['name' => 'Janus Nic']);
                // Здесь всего навсего формирвется страница при помощи шаблона welcome.
            }

        }


Контроллеры и пространства имён
-------------------------------
Важно помнить, что нам не надо указывать полное пространство имён контроллера, а только ту часть имени класса, которая следует за «корнем» пространства имён — App\Http\Controllers. По умолчанию RouteServiceProvider загрузит файл routes.php вместе с группой маршрутизации, содержащей корневое пространство имён контроллера.

Если вы решите разместить свои контроллеры, используя пространства имён PHP, в поддиректориях App\Http\Controllers, то просто используйте конкретное имя класса относительно корня пространства имён App\Http\Controllers. Тогда, если полный путь к вашему классу будет App\Http\Controllers\Bar\BarController, то вы зарегистрируете маршрут вот так:

        Route::get('foo', 'Bar\BarController@method');

Имена маршрутов контроллеров
----------------------------
Подобно маршрутам замыканий, вы можете указать имена для маршрутов контроллеров:

        Route::get('foo', ['uses' => 'FooController@method', 'as' => 'name']);

URL-адреса для действий контроллера
-----------------------------------
Для получения URL для действия контроллера используйте метод action:

        $url = action('App\Http\Controllers\FooController@method');
Если вы хотите получить URL для действия контроллера, используя только часть имени класса относительно пространства имён контроллера, зарегистрируйте корневое пространство имён контроллера с помощью генератора URL:

        URL::setRootControllerNamespace('App\Http\Controllers');

        $url = action('FooController@method');
Получить имя действия, которое выполняется в данном запросе, можно методом currentRouteAction:

        $action = Route::currentRouteAction();

"Как это работает?".
--------------------

В Laravel все маршруты описываются вручную в файле app/Http/routes.php

Сейчас по-умолчанию для создания Greeting страницы используется следующая команда:

Route::get('/hey', 'GreetingController@index');

С помощью класса Route мы для формирования главной страницы http://lara.com/hey будем использовать GreetingController.php и метод index().

Контроллеры находятся в папке app/Http/Controllers.

Представления в Ларавел 5 лежат в папке resources/views/

Модели по-умолчанию создаются в папке app/
------------------------------------------
Автор фреймворка решил что модели это все же больше бизнес-логика приложения и соответственно всецело лежит на разработчике. Соответственно сам разработчик волен выбирать где хранить модели. 

RESTful-контроллеры ресурсов
----------------------------
Контроллеры ресурсов упрощают построение RESTful-контроллеров, работающих с ресурсами. 
И у нас сразу имеются готовые методы index, create, store, show, edit, update, destroy.
Например, вы можете создать контроллер с помощью Artisan-команды make:controller:

        php artisan make:controller PostController

Теперь мы можем зарегистрировать маршрут контроллера ресурса:

        Route::resource('posts', 'PostController');

Этот единственный вызов создаёт множество маршрутов для обработки различных RESTful-действий на ресурсе posts. Сам сгенерированный контроллер уже имеет методы-заглушки для каждого из этих действий с комментариями о том, какие типы запросов они обрабатывают.

Действия, обрабатываемые контроллером ресурсов

             php artisan route:list 

            Domain | Method    | URI                | Name Action   Middleware |

            |        | GET|HEAD  | /                  |               | Closure                                       | web        |
            |        | GET|HEAD  | hay                |               | Closure                                       | web        |
            |        | GET|HEAD  | hell               |               | Closure                                       | web        |
            |        | GET|HEAD  | hell1              |               | Closure                                       | web        |
            |        | GET|HEAD  | hell2              |               | Closure                                       | web        |
            |        | GET|HEAD  | hey                |               | App\Http\Controllers\GreetingController@index | web        |
            |        | POST      | posts              | posts.store   | App\Http\Controllers\PostController@store     | web        |
            |        | GET|HEAD  | posts              | posts.index   | App\Http\Controllers\PostController@index     | web        |
            |        | GET|HEAD  | posts/create       | posts.create  | App\Http\Controllers\PostController@create    | web        |
            |        | GET|HEAD  | posts/{posts}      | posts.show    | App\Http\Controllers\PostController@show      | web        |
            |        | PUT|PATCH | posts/{posts}      | posts.update  | App\Http\Controllers\PostController@update    | web        |
            |        | DELETE    | posts/{posts}      | posts.destroy | App\Http\Controllers\PostController@destroy   | web        |
            |        | GET|HEAD  | posts/{posts}/edit | posts.edit    | App\Http\Controllers\PostController@edit      | web        |


Настройка маршрутов ресурсов
============================
Вы можете указать подмножество всех возможных действий, которые должны обрабатываться по маршруту:

Route::resource('posts', 'PostController',
        ['only' => ['index', 'show']]);

Route::resource('posts', 'PostController',
        ['except' => ['create', 'store', 'update', 'destroy']]);

По умолчанию все действия контроллера ресурсов имеют имена маршрутов, но вы можете переопределить эти имена, передав массив names вместе с остальными параметрами:

Route::resource('posts', 'PostController',
        ['names' => ['create' => 'posts.build']]);

Обработка контроллеров вложенных ресурсов
=========================================
Используйте «точечную» нотацию в объявлении маршрута для контроллеров «вложенных» ресурсов:

Route::resource('posts.comments', 'PostCommentController');
Этот маршрут зарегистрирует «вложенный» ресурс, к которому можно обратиться по такому URL: posts/{posts}/comments/{comments}.

class PostCommentController extends Controller {

  public function show($postsId, $commentId)
  {
    //
  }

}
Добавление дополнительных маршрутов в контроллеры ресурсов
-----------------------------------------------------------
Когда вам необходимо добавить дополнительные маршруты в контроллер ресурсов, не входящие в маршруты ресурсов по умолчанию, их надо определить до вызова Route::resource:

Route::get('posts/popular', 'PostController@method');

Route::resource('posts', 'PostController');

Сделаем так чтобы главную страницу сайта формировал PostController и index() метод.

Для этого заккоментируем строку в которой мы задаем маршрут для главной страницы и напишем новую строку кода:

        get('/', ['as' => 'posts', 'uses' => 'PostController@index']);

Laravel очень гибок - есть много способов решить одну и ту же задачу. Как вы видете код мы записали иначе, а задачу он выполняет ту же. Вторым параметром функции get() мы задаем массив, в котором указываем имя нашего нового Маршрута - posts и контроллер с методом которые будут формировать странцу.

Уже из написания приходит понимание что Route::get() и просто get() - создают маршрут GET запроса.
Логично предположить что для пост запроса мы будем использовать post(). В ларавел - всё логично 

Для каждого экшена (метод класса который формирует определенную страницу) у нас будет свой шаблон, своё представление. В папке resources/views/ создадим папку post (идентично с контролером для которого здесь будут храниться представления). И в этой папке создадим файл index.blade.php (так же пусть имя представления будет идентично имени метода которые формирует страницу). И заполним тестовым текстом.

Теперь нам надо в PostConroller::index() использовать наше представление:

        public function index()
        {
               return view('post.index');
        }

Вызываем функцию view()! И передаем ей параметром ПУТЬ.ИМЯ нужного представления. (Конечно было бы еще логичнее чтобы Ларавел, если параметр не указан, сам догадывался подставить ИМЯ_КОНТРОЛЛЕРА.ИМЯ_МЕТОДА.... )))) )

post/index.blade.php
--------------------
        @extends('layouts.master')

        @section('title', 'Заголовок страницы')

        @section('sidebar')

            @parent

            <p>Этот элемент будет добавлен к главному сайдбару.</p>
            Текущее время эпохи UNIX: {{ time() }}.
        @stop

        @section('content')
            <div class="content">
                        <div class="title">Laravel 5</div>
            </div>

            <p>Это - содержимое страницы.</p>
           
        @stop



