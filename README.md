# web-dev unit_05

class
=====

Описание классов в PHP начинаются служебным словом class:
        class Имя_класса {
        // описание членов класса - свойств и методов для их обработки
        }
Для объявления объекта необходимо использовать оператор new:
        Объект = new Имя_класса;
Данные описываются с помощью служебного слова var. Метод описывается так же, как и обыкновенная пользовательская функция. Методу также можно передавать параметры. 

Каждому объявлению свойства, содержащегося в классе, должно предшествовать ключевое слово var. Свойства могут относиться к любому типу данных, поддерживаемых в РНР, их можно рассматривать как переменные с небольшими различиями. После объявлений свойств следуют объявления методов, очень похожие на типичные объявления пользовательских функций.
По общепринятым правилам имена классов ООП начинаются с прописной буквы, а все слова в именах методов, кроме первого, начинаются с прописных букв (первое слово начинается со строчной буквы). Разумеется, вы можете использовать любые обозначения, которые сочтете удобными; главное — выберите стандарт и придерживайтесь его.

Пример класса на PHP:
---------------------
        <?php
        // Создаем новый класс Cool:
        class Cool {
        // данные (свойства):
        var $name;
        var $addr;
        // методы:
         function Name() {
         echo "<h3>John</h3>";
         }
        }
        // Создаем объект класса Cool:
        $object = new Cool;
        ?>


Доступ к класам и объектам в PHP
--------------------------------
Теперь нам необходимо получить доступ к членам класса, для этого в PHP предназначен оператор ->. 

        <?php
        
        // Создаем новый класс Cool:
        class Cool {
        
            // данные (свойства):
            var $name;
            
            // методы:
             function Getname() {
             echo "<h3>John</h3>";
             }
        }
        
        // Создаем объект класса Cool:
        $object = new Cool;
        
        // Получаем доступ к членам класса:
        $object->name = "Alex";
        echo $object->name;
        // Выводит 'Alex'
        
        // А теперь получим доступ к методу класса (фактически, к функции внутри класса):
        $object->Getname();
        // Выводит 'John' заглавными буквами
        ?>

указатель $this
---------------
Чтобы получить доступ к членам класса внутри класса, необходимо использовать указатель $this, которы всегда относится к текущему объекту. Модифицированный метод Getname():

    function Getname() {
        echo $this->name;
    }

метод Setname():
    function Setname($name) {
        $this->name = $name;
    }

Теперь для изменения имени можно использовать метод Setname():

    $object->Setname("Peter"); 
    $object->Getname();

полный листинг кода:
        <?php
        // Создаем новый класс Cool:
        class Cool {
            // данные (свойства):
            var $name;
            // методы:
             function Getname() {
                echo $this->name;
             }
             function Setname($name) {
                $this->name = $name;
             }
        }
        // Создаем объект класса Cool:
        $object = new Cool;
        // Теперь для изменения имени используем метод Setname():
        $object->Setname("Nick");
        // А для доступа, как и прежде, Getname():
        $object->Getname();
        // Сценарий выводит 'Nick'
        ?>

Указатель $this можно также использовать для доступа к методам, а не только для доступа к данным:

    function Setname($name) {
            $this->name = $name;
            $this->Getname();
    }

Конструкторы
============
Конструктор представляет собой метод, который задает значения некоторых свойств (может вызывать другие методы). Конструкторы вызываются автоматически при создании новых объектов. Чтобы это стало возможным, имя метода-конструктора должно совпадать с именем класса, в котором он содержится. Пример конструктора:
    
    class Comunity { 
         var $name; 
         var $addr; 
        
        // Конструкторы вызываются автоматически при создании новых объектов
        function Comunity($name) { 
            $this->name = $name; 
              } 
          function Getname() { 
            echo $this->name; 
          } 
          function Setname($name) { 
            $this->Getname(); 
          } 
    }; 
    
    // Вызвать конструктор класса  Comunity
    $object = new Comunity('Alle'); 
    echo $object->name; 
    $object->name = 'Bob'; 
    }
Конструкторы позволяют выполнить эти действия за один этап. 

в зависимости от количества передаваемых параметров могут вызываться разные конструкторы. В рассмотренном примере объекты класса Comunity могут создаваться двумя способами. Во-первых, вы можете вызвать конструктор, который просто создает объект, но не инициализирует его свойства:
    $page = new Comunity;
Во-вторых, объект можно создать при помощи конструктора, определенного в классе, — в этом случае вы создаете объект класса Comunity и присваиваете значение его свойству bgcolor:
    $page = new Webpage("brown");
Деструкторы - функция unset()
=============================
Эта функция уничтожает содержимое переменной и возвращает занимаемые ею ресурсы системе. С объектами unset() работает так же, как и с переменными. Допустим, вы работаете с объектом $Webpage. После завершения работы с этим конкретным объектом вызывается функция:
    unset($object0); 
Эта команда удаляет из памяти все содержимое $Webpage. Действуя в духе инкапсуляции, можно поместить вызов unset() в метод с именем destroy() и затем вызвать его:
    $object0->destroy(); 
Необходимость в вызове деструкторов возникает лишь при работе с объектами, использующими большой объем ресурсов, поскольку все переменные и объекты автоматически уничтожаются по завершении сценария.

      function destoy() { 
            unset($this); 
        } 
    }; 

    $object0 = new Comunity; 
    $object0->name = 'Bob'; 
    echo $object0->name; 
    $object0->destoy(); 

Инициализация объектов
======================
Иногда возникает необходимость выполнить инициализацию объекта - присвоить его свойствам первоначальные значения. Предположим, имя класса Cool и он содержит два свойства:имя человека и город его проживания. Можно написать метод (функцию), который будет выполнять инициализацию объекта, например Init():

    <?php
    class Comunity { 
      var $name; 
      var $addr; 
      // Инициализирующий метод:
     function Init($name) {
        $this->name = $name; 
          } 
      function Getname() { 
        echo $this->name; 
      } 
      function Setname($name) { 
        $this->Getname(); 
        } 
    }; 
    
    $object0 = new Comunity; 
    // Для инициализации объекта сразу вызываем метод:
    $object0->Init('Bob'); 
    echo $object0->name;
    $this->name = $name;

Главное не забыть вызвать функцию сразу после создания объекта, либо вызвать какой-нибудь метод между созданием (оператор new) объекта и его инициализацией (вызовом Init).
Для того, чтобы PHP знал, что определенный метод нужно вызывать автоматически при создании объекта, ему нужно дать имя такое же, как и у класса (Cool):
    function Comunity ($name)
    $this->name = $name;
    $this->city = "London";
    }
Метод, инициализирующий объект, называется конструктором. Однако, PHP не имеет деструкторов, поскольку ресурсы освобождаюся автоматически при завершении работы скриптов.

Обращение к элементам классов
=============================
Обращение к элементам классов осуществляется с помощью оператора :: "двойное двоеточие". Используя "двойное двоеточие", можно обращаться к методам классов.
При обращении к методам классов, программист должен использовать имена этих классов.
    
    <?php
    class A {
         function example() {
             echo "Это первоначальная функция A::example().<br>";
         }
    }
    class B extends A {
         function example() {
             echo "Это переопределенная функция B::example().<br>";
             A::example();
         }
    }
    // Не нужно создавать объект класса A.
    // Выводит следующее: 
    // Это первоначальная функция A::example().
    A::example();
    // Создаем объект класса B.
    $b = new B;
    // Выводит следующее: 
    //   Это переопределенная функция B::example().
    //   Это первоначальная функция A::example().
    $b->example();
    ?>

Наследование классов в PHP
==========================
Наследование - это не просто создание точной копии класса, а расширение уже существующего класса, чтобы потомок мог выполнять какие-нибудь новые, характерные только ему функции.
Итак, пусть у нас есть некоторый класс A с определенными свойствами и методами. Но то, что этот класс делает, нас не совсем устраивает — например, пусть он выполняет большинство функций, но не реализует некоторых других. Зададимся целью создать новый класс B, расширяющий возможности класса A, добавляющий ему несколько новых свойств и методов. Сделать это можно двумя принципиально различными способами. 

Первый выглядит так:
--------------------
    <?php
    class A {
      function TestA() { ... }
      function Test() { ... }
    }
    class B {
      var $a; // объект класса A
      function B(параметры_для_A, другие_параметры){ 
        $a = new A(параметры_для_A);
        // инициализируем другие поля B
      }
      function TestB() { ... }
      function Test() { ... }
    }
в этой реализации объект класса B содержит в своем составе подобъект класса A в качестве свойства. Это свойство — лишь "частичка" объекта класса B, не более того. Подобъект не "знает", что он в действительности не самостоятелен, а содержится в классе B, поэтому не может предпринимать никаких действий, специфичных для этого класса. 
Мы хотели получить расширение возможностей класса A. Что означает "расширение" - мы бы хотели, чтобы везде, где допустима работа с объектами класса A, была допустима и работа с объектами класса B. Но в приведенном примере это совсем не так. 

Итак, мы имеем некоторые проблемы: 
1. Мы не видим явно, что класс B лишь расширяет возможности A, а не является отдельной сущностью;
2. Мы должны обращаться к "части A" класса B через $obj->a->TestA(), а к членам самого класса B как $obj->TestB(). 

расширение возможностей классов:
--------------------------------
        <?php
        class B extends A {
          function B(параметры_для_A, другие_параметры) { 
            $this->A(параметры_для_A);
            // инициализируем другие поля B
          }

          function TestB() { ... }
          function Test() { ... }
        }
Ключевое слово extends говорит о том, что создаваемый класс является лишь "расширением" класса A, и не более того. То есть B содержит те же самые свойства и методы, что и A, но, помимо них и еще некоторые дополнительные, "свои". Теперь "часть A" находится прямо внутри класса B и может быть легко доступна, наравне с методами и свойствами самого класса B. Например, для объекта $obj класса B допустимы выражения $obj->TestA() и $obj->TestB(). 
Итак, мы видим, что, действительно, класс B является воплощением идеи "расширение функциональности класса A". Обратите также внимание: мы можем теперь забыть, что B унаследовал от A некоторые свойства или методы — снаружи все выглядит так, будто класс B реализует их самостоятельно. 

родительский класс A принято называть базовым классом, а класс дочерний класс B — производным от A. Иногда базовый класс также называют суперклассом, а производный — подкласcом.


        <?php
        class Parent {
          function parent_funct() { echo "<h1>Это родительская функция</h1>"; }
          function test () { echo "<h1>Это родительский класс</h1>"; }
        }

        class Child extends Parent {
          function child_funct() { echo "<h2>Это дочерняя функция</h2>"; }
          function test () { echo "<h2>Это дочерний класс</h2>"; }
        }
        $object = new Parent;
        $object = new Child;
        $object->parent_funct(); // Выводит 'Это родительская функция'
        $object->child_funct(); // Выводит 'Это дочерняя функция'
        $object->test(); // Выводит 'Это дочерний класс'
Дочерний класс (подкласс) Child наследует все методы и свойства суперкласса Parent.
Полиморфизм классов в PHP
-------------------------
Полиморфизм (многоформенность) является следствием идеи наследования. В общих словах, полиморфность класса — это свойство базового класса использовать функции производных классов, даже если на момент определения еще неизвестно, какой именно класс будет включать его в качестве базового и, тем самым, становиться от него производным.
Рассмотрим свойство полиморфности классов на основе следующего примера:

    <?php
    class A {
    // Выводит, функция какого класса была вызвана
    function Test() { echo "Test from A\n"; }
    // Тестовая функция — просто переадресует на Test()
    function Call() { Test(); }
    }
    class B extends A {
    // Функция Test() для класса B
    function Test() { echo "Test from B\n"; }
    }
    $a=new A();
    $b=new B();
    ?>
Используем следующие следующие команды:
    $a->Call(); // выводит "Test from A"
    $b->Test(); // выводит "Test from B"
    $b->Call(); // Внимание! Выводит "Test from B"!

Обратите внимание на последнюю строчку: вопреки ожиданиям, вызывается не функция Test() из класса A, а функция из класса B! Складывается впечатление, что Test() из B просто переопределила функцию Test() из A. Так оно на самом деле и есть. Функция, переопределяемая в производном классе, называется виртуальной.
Механизм виртуальных функций позволяет, например, "подсовывать" функциям, ожидающим объект одного класса, объект другого, производного, класса. 

Еще один классический пример — класс, воплощающий собой свойства геометрической фигуры, и несколько производных от него классов — квадрат, круг, треугольник и т. д. Базовый класс имеет виртуальную функцию Draw(), которая заставляет объект нарисовать самого себя. Все производные классы-фигуры, разумеется, переопределяют эту функцию (ведь каждую фигуру нужно рисовать по-особому). Также у нас есть массив фигур, причем мы не знаем, каких именно. Зато, используя полиморфизм, мы можем, не задумываясь, перебрать все элементы массива и вызвать для каждого из них метод Draw() — фигура сама "решит", какого она типа и как ее рисовать.

А вот еще один практический пример, показывающий свойство класса - полиморфизм:

    <?php
    class Base {
     function funct() {
     echo "<h2>Функция базового класса</h2>";
     }
     function base_funct() {
     $this->funct();
     }
    }
    class Derivative extends Base {
     function funct() {
     echo "<h3>Функция производного класса</h3>";
     }
    }
    $b = new Base();
    $d = new Derivative();
    $b->base_funct();
    $d->funct();
    $d->base_funct();
    // Скрипт выводит:
    // Функция базового класса
    // Функция производного класса
    // Функция производного класса
    ?>

class Depart
------------
    class Depart extends Comunity { 
      function Getname() { 
        echo 'This is department name '.$this->name; 
      } 
    } 
    $object = new Depart('New community'); 
    $object->Getname(); 

Работа с объектами классов PHP
==============================
Копирование объектов
--------------------

В PHP 5 объектная модель была полностью переписана для того, чтобы сразу работать с указателями на объект. Если вы явно не клонируете объект, используя ключевое слово clone, вы никогда не будете работать с копией объекта, думая, что работаете с самим объектом. В PHP 5 уже не нужно явно передавать объекты или присваивать их по ссылке, это делается автоматически.

public/private/protected - модификаторы доступа для методов и свойств 
---------------------------------------------------------------------
Позволяют управлять доступом к методам и свойствам. Теперь видимость свойств и методов может быть определена ключевыми словами: public, private, protected. 

Модификатор public 
------------------
позволяет обращаться к свойствам и методам отовсюду. 
Модификатор private 
-------------------
позволяет обращаться к свойствам и методам только внутри текущего класса. 
Модификатор protected 
---------------------
позволяет обращаться к свойствам и методам только текущего класса и класса, который наследует свойства и методы текущего класса.
        <?php
        /**
          * Define MyClass
          */
        class MyClass
        {
             public $public = 'Public';
             protected $protected = 'Protected';
             private $private = 'Private';
             function printHello()
             {
                 echo $this->public;
                 echo $this->protected;
                 echo $this->private;
             }
        }
        $obj = new MyClass();
        echo $obj->public; // Works
        echo $obj->protected; // Fatal Error
        echo $obj->private; // Fatal Error
        $obj->printHello(); // Shows Public, Protected and Private
        /**
          * Define MyClass2
          */
        class MyClass2 extends MyClass
        {
             // We can redeclare the public and protected method, but not private
             protected $protected = 'Protected2';
             function printHello()
             {
                 echo $this->public;
                 echo $this->protected;
                 echo $this->private;
             }
        }
        $obj2 = new MyClass2();
        echo $obj->public; // Works
        echo $obj2->private; // Undefined
        echo $obj2->protected; // Fatal Error
        $obj2->printHello(); // Shows Public, Protected2, not Private
        ?>

Унифицированный конструктор __construct()
-----------------------------------------
PHP 5 позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-констуктор, будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, чтобы, например, инициализировать какое-либо состояние объекта перед его использованием. Конструктор, ранее совпадавший с названием класса, теперь необходимо объявлять как __construct(), что позволит легче перемещать классы в иерархиях. Конструкторы в классах-родителях не вызываются автоматически. Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу parent::__construct().
        <?php
        class BaseClass {
             function __construct() {
                 print "Конструктор класса BaseClass\n";
             }
        }
        class SubClass extends BaseClass {
             function __construct() {
                 parent::__construct();
                 print "Конструктор класса SubClass\n";
             }
        }
        $obj = new BaseClass();
        $obj = new SubClass();
        ?>
Если PHP 5 не может обнаружить объявленный метод __construct(), вызов конструктора произойдет по прежней схеме, через обращение к методу, имя которого соответствует имени класса. Может возникнуть только одна проблема совместимости старого кода, если в нём присутствуют классы с методами __construct().

Поддержка деструктора для класса, определяемого как метод __destructor() PHP 5 предоставляет концепцию деструкторов, сходную с теми, что применяются в других ОО языках, таких, как Java: когда освобождается последняя ссылка на объект, перед высвобождением памяти, занимаемой этим объектом, вызывается метод __destruct(), не принимающий параметров.
        <?php
        class MyDestructableClass {
             function __construct() {
                 print "Конструктор\n";
                 $this->name = "MyDestructableClass";
             }
             function __destruct() {
                 print "Уничтожается " . $this->name . "\n";
             }
        }
        $obj = new MyDestructableClass();
        ?>
Как и в случае с конструкторами, деструкторы, объявленные в родительском классе, не будут вызваны автоматически. Для вызова деструктора, объявленном в классе-родителе, следует обратиться к методу parent::__destruct().

Свойства 
========= 
Переменные, которые являются членами класса, называются "свойства" (аттрибуты или поля). Они определяются с помощью ключевых слов public, protected, или private, следуя правилам правильного описания переменных. Это описание может содержать инициализацию, но инициализация дожна применяться для константных значений - то есть, переменные должны быть вычислены во время компиляции и не должны зависеть от информации программы во время выполнения для их вычисления. 

Для того, чтобы поддерживать обратную совместимость с PHP 4, PHP 5 по-прежнему позволяет использовать ключевое слово var при определении свойств вместо (или в дополнении к) public, protected, или private. Однако, var больше не требуется. В версиях PHP с 5.0 по 5.1.3, использование var считалось устаревшим вызывало E_STRICT предупреждение, но с PHP 5.1.3 больше не считается устаревшим и не выдает предупреждения. 

Если, для определения свойства, вы используете var вместо одного из: public, protected, или private, тогда PHP 5 будет определять свойство как public. 

В пределах методов класса доступ к нестатическим свойствам может быть получен с помощью -> (объектного оператора): $this->property (где property - имя свойства). Доступ к статическим свойствам может быть получен с помощью :: (двойного двоеточия): self::$property. 

Псевдо-переменная $this доступна внутри любого метода класса, когда этот метод вызывается в пределах объекта. $this - это ссылка на вызываемый объект (обычно, объект, которому принадлежит метод, но возможно и другого объекта, если метод вызван статически из контекста второго объекта). 

Определение свойств 
-------------------
        class test 
        { 
            public $var1 = 1; 
            protected $var2 = 2; 
            private $var3 = 3; 
            static $var4 = 4; 
            public function toArray() 
            { 
                return (array) $this; 
            } 
        } 
        $t = new test; 
        print_r($t->toArray()); 
        /* outputs: 
        Array 
        ( 
            [var1] => 1 
            [ * var2] => 2 
            [ test var3] => 3 
        ) 
        */ 
        ?> 


MySQL
=====
Расширение mysqli 
-----------------
позволяет вам получить доступ к функциональности, которую предоставляет MySQL версии 4.1 и выше.

Документация MySQL находится по адресу » http://dev.mysql.com/doc/.

Все примеры, приведенные в документации к mysqli, используют базу данных world. Базу данных world вы можете найти по адресу » http://dev.mysql.com/doc/world-setup/en/index.html

Процедурный и объектно-ориентированный интерфейс 
================================================
Расширение mysqli предоставляет двойной интерфейс программисту. Поддерживаются как процедурная, так и объектно-ориентированная парадигмы программирования.

Простота перехода со старого mysql расширения

        <?php
        $mysqli = mysqli_connect("example.com", "user", "password", "database");
        $res = mysqli_query($mysqli, "SELECT 'Пожалуйста, не используюте ' AS _msg FROM DUAL");
        $row = mysqli_fetch_assoc($res);
        echo $row['_msg'];

        $mysql = mysql_connect("example.com", "user", "password");
        mysql_select_db("test");
        $res = mysql_query("SELECT 'расширение mysql в новых проектах.' AS _msg FROM DUAL", $mysql);
        $row = mysql_fetch_assoc($res);
        echo $row['_msg'];
        ?>


Объектно-ориентированный интерфейс
----------------------------------
В дополнение к процедурному пользователи могут использовать объектно-ориентированный интерфейс. Документация заточена именно под объектный интерфейс. Объектно-ориентированный интерфейс предлагает функции сгруппированные по цели их применения, что облегчает их поиск и освоение. Тем не менее, в практических примерах к функциям приводится код для обеих парадигм.

Объектно-ориентированный и процедурный интерфейсы

        <?php

        $servername = "localhost";
        $username = "username";
        $password = "password";


        $mysqli = mysqli_connect("example.com", "user", "password", "database");
        if (mysqli_connect_errno($mysqli)) {
            echo "Не удалось подключиться к MySQL: " . mysqli_connect_error();
        }

        $res = mysqli_query($mysqli, "SELECT 'A world full of ' AS _msg FROM DUAL");
        $row = mysqli_fetch_assoc($res);
        echo $row['_msg'];

        // (MySQLi Object-Oriented)
        
        // Create connection
        $mysqli = new mysqli("example.com", "user", "password", "database");
        // Check connection
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: " . $mysqli->connect_error;
        }

        $res = $mysqli->query("SELECT 'choices to please everybody.' AS _msg FROM DUAL");
        $row = $res->fetch_assoc();
        echo $row['_msg'];
        ?>

Смешивание стилей
------------------
Переключаться между стилями программирования можно сколь угодно часто и в любое время, однако делать этого не рекомендуется, так как это ухудшает читаемость кода и затрудняет его поддержку.

Плохой стиль программирования

    <?php
    $mysqli = new mysqli("example.com", "user", "password", "database");
    if ($mysqli->connect_errno) {
        echo "Не удалось подключиться к MySQL: " . $mysqli->connect_error;
    }

    $res = mysqli_query($mysqli, "SELECT 'Этот код работает, но лучше так не писать.' AS _msg FROM DUAL");
    if (!$res) {
        echo "Не удалось выполнить запрос: (" . $mysqli->errno . ") " . $mysqli->error;
    }

    if ($row = $res->fetch_assoc()) {
        echo $row['_msg'];
    }
    ?>

Соединения 
==========
Сервер MySQL поддерживает различные способы передачи данных. Соединения могут использовать TCP/IP протоколы, сокеты Unix доменов или именованные пайпы Windows.

Имя хоста localhost имеет специальное назначение. Оно используется только в сокетах Unix доменов. Невозможно открыть TCP/IP соединение, используя в качестве имени хоста localhost. Вместо него нужно задать 127.0.0.1.

Специальное назначение localhost

        <?php
        $mysqli = new mysqli("localhost", "user", "password", "database");
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
        }
        echo $mysqli->host_info . "\n";

        $mysqli = new mysqli("127.0.0.1", "user", "password", "database", 3306);
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
        }

        echo $mysqli->host_info . "\n";
        ?>

Умолчания для параметров соединений
-----------------------------------
В зависимости от функции, осуществляющей подключение, какие-то параметры можно не задавать. Если параметр не задан, расширение попытается использовать значение по умолчанию для этого параметра, которое задано в конфигурационном файле PHP.

Задание значений по умолчанию

        mysqli.default_host=192.168.2.27
        mysqli.default_user=root
        mysqli.default_pw=""
        mysqli.default_port=3306
        mysqli.default_socket=/tmp/mysql.sock

Далее, чтобы установить соединение, функция передает параметры в клиентскую библиотеку, которой пользуется расширение. Если библиотека обнаружит пустые или отсутствующие параметры, она может подставить вместо них свои встроенные значения по умолчанию.

        //database credentials
        
        define('DBHOST','localhost');
        define('DBUSER','username');
        define('DBPASS','password');
        define('DBNAME','database name');

Встроенные библиотечные умолчания для параметров соединения
-----------------------------------------------------------
Если имя хоста не задано или передана пустая строка, клиентская библиотека использует для подключения к Unix сокету хоста localhost. Если сокет не задан или передана пустая строка, и при этом запрошено подключение к Unix сокету, библиотека попытается подключиться к сокету /tmp/mysql.sock.

В Windows системах, если в качестве имени хоста передается ., библиотека попытается открыть соединение на основе именованного пайпа. В этом случае имя сокета будет воспринято, как имя пайпа. Если имя сокета не задано, то будет использовано значение 

    \\.\pipe\MySQL.

Если соединение не использует ни сокет Unix домена, ни именованный пайп Windows, и при этом не задан порт для подключения, библиотека использует номер порта 3306.

В драйвере mysqlnd и Клиентской библиотеке MySQL (libmysqlclient) заложена та же логика определения умолчаний.

Настройки соединения
=====================
Настройки соединения позволяют, задать какие-то команды, которые нужно выполнить сразу после подключения, или отдать распоряжение использовать определенный набор символов. Настройки должны быть заданы до подключения к серверу.

Когда требуется задать настройки соединения, операция подключения выполняется в три этапа: функцией mysqli_init() создается дескриптор подключения, затем подключение настраивается с помощью функции mysqli_options(), и наконец устанавливается сетевое соединение с сервером посредством функции mysqli_real_connect().

Объединение подключений в пул
-----------------------------
Расширение mysqli поддерживает постоянные соединения с базой данных, которые представляют из себя специальный вид объединяемых соединений. По умолчанию, каждое открытое скриптом соединение закрывается либо самим скриптом в ходе выполнения, либо автоматически по завершении работы скрипта. Постоянные соединения отличаются тем, что не закрываются, а помещаются в пул для повторного использования в дальнейшем. Если требуется подключиться к тому же серверу и базе данных, с тем же именем пользователя, паролем, сокетом и портом, то вместо создания нового подключения из пула извлекается уже существующее. Повторное использование подключений позволяет избежать накладных расходов на создание новых соединений.

Каждый PHP процесс использует свой пул подключений mysqli. В зависимости от конфигурации веб-сервера, PHP процесс может обслуживать один или несколько запросов. Соответственно, соединение из пула могут последовательно использовать несколько скриптов.

Постоянное соединение
----------------------
Новое подключение создается, только если в пуле не найдется свободного подключения с теми же данными хоста, имени пользователя, пароля, сокета, порта и базы данных по умолчанию. Механизм постоянных соединений можно включать и выключать PHP директивой mysqli.allow_persistent. Максимальное количество соединений, которые может открыть скрипт, ограничено значением mysqli.max_links. Максимальное количество соединений, которые может открыть один PHP процесс, ограничено значением mysqli.max_persistent. Следует заметить, что веб-сервер может порождать множество PHP процессов.

Главный недостаток постоянных подключений заключается в том, что перед повторным использованием их состояние не сбрасывается к изначальному. Например, открытые и незавершенные транзакции не будут автоматически откатываться. Также, если во время нахождения соединения в пуле для процесса изменились какие-либо разрешения или уровни доступа, этот факт никак не отразится на подключении при его извлечении из пула. Такое поведение может привести к нежелательным результатам. Хотя, с другой стороны, название постоянный можно рассматривать, как обещание, что подключение и правда останется в том состоянии, в котором оно было помещено в пул.

Расширение mysqli поддерживает обе интерпретации термина постоянное соединение: состояние соединения может сохраняться, а может и сбрасываться в изначальное. По умолчанию, при извлечении из пула соединение сбрасывается. mysqli делает это неявным вызовом функции mysqli_change_user() каждый раз, когда подключение используется повторно. С точки зрения пользователя подключение выглядит, как только что созданное.

Однако, вызов функции mysqli_change_user() довольно дорогостоящая операция. Для улучшения быстродействия можно перекомпилировать расширение с установленным флагом MYSQLI_NO_CHANGE_USER_ON_PCONNECT.

Выбор между безопасным поведением подключений и наилучшим быстродействием остается за пользователем. Здесь нельзя дать однозначного совета. Для простоты использования, по умолчанию включен безопасный режим с очисткой соединений.

Выполнение запросов 
===================
За выполнение запросов отвечают функции mysqli_query(), mysqli_real_query() и mysqli_multi_query(). Чаще всего применяется функция mysqli_query(), так как она выполняет сразу две задачи: выполняет запрос и буферизует на клиенте результат этого запроса (если он есть). Вызов mysqli_query() идентичен последовательному вызову функций mysqli_real_query() и mysqli_store_result().

Подключение к MySQL
-------------------

bootstrap/app.php
-----------------

        <?php
        ob_start();
        session_start();

        //set timezone
        date_default_timezone_set('Europe/Kiev');

        //database credentials

        define('DBHOST','localhost');
        define('DBUSER','dev');
        define('DBPASS','ghbdtn');
        define('DBNAME','webdev');


public/init.php
---------------
        <?php
        require_once __DIR__.'/../bootstrap/app.php';
        ?>

        <!DOCTYPE html>
        <html class=''>
        <head>
        <meta charset='UTF-8'>
        </head><body>

        <?php
                $mysqli = new mysqli(DBHOST, DBUSER, DBPASS, DBNAME);
                if ($mysqli->connect_errno) {
                    echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
                }

                if (!$mysqli->query("DROP TABLE IF EXISTS blog_posts") ||
                    !$mysqli->query("CREATE TABLE blog_posts(id INT)") ||
                    !$mysqli->query("INSERT INTO blog_posts(id) VALUES (1)")) {
                    echo "Не удалось создать таблицу: (" . $mysqli->errno . ") " . $mysqli->error;
                }} else {
                    echo "Database created successfully";
                }
                $mysqli->close();

        ?>

Database: `webdev`
------------------
        --
        -- Database: `webdev`
        --
        -- --------------------------------------------------------
        --
        -- Table structure for table `blog_posts`
        --
        CREATE TABLE IF NOT EXISTS `blog_posts` (
          `id` int(11) DEFAULT NULL
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
        --
        -- Dumping data for table `blog_posts`
        --
        INSERT INTO `blog_posts` (`id`) VALUES (1);
        Example (MySQLi Object-oriented)



init.php
--------
        <?php
                $mysqli = new mysqli(DBHOST, DBUSER, DBPASS, DBNAME);
                if ($mysqli->connect_errno) {
                    echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
                }

                if (!$mysqli->query("DROP TABLE IF EXISTS blog_posts") ||
                    !$mysqli->query("CREATE TABLE blog_posts(id int(11) unsigned NOT NULL AUTO_INCREMENT ,title varchar(255) DEFAULT NULL, description text, content text, created datetime DEFAULT NULL, PRIMARY KEY(id))")) {
                    echo "Не удалось создать таблицу: (" . $mysqli->errno . ") " . $mysqli->error;
                }
        ?>

# Dump of table blog_posts

        DROP TABLE IF EXISTS `blog_posts`;

        CREATE TABLE `blog_posts` (
          `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
          `title` varchar(255) DEFAULT NULL,
          `description` text,
          `content` text,
          `created` datetime DEFAULT NULL,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;


Буферизация результатов запроса
-------------------------------
После выполнения запроса его результаты можно целиком буферизовать на клиенте, либо читать построчно с сервера. Буферизация на клиенте позволяет серверу как можно быстрее освобождать занятые запросом ресурсы. Построчное же чтение и дальнейшая обработка результатов клиентом довольно медленный процесс. Поэтому рекомендуется использовать буферизацию результирующих наборов. Функция mysqli_query() совмещает в себе операции выполнения запроса и буферизации результирующего набора.

        $mysqli = new mysqli(DBHOST, DBUSER, DBPASS, DBNAME);
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
        }

        if (!$mysqli->query("INSERT INTO `blog_posts` (`id`, `title`, `description`, `content`, `created`) VALUES  (1, 'Bendless Love','<p>That\'s right, baby. I ain
        ...
        )")) {
            echo "Не удалось insert into таблицу: (" . $mysqli->errno . ") " . $mysqli->error;
        } 

PHP приложения могут свободно оперировать данными внутри буферизованных результирующих наборов. Быстрая навигация по строкам наборов обусловлена тем, что наборы полностью располагаются в памяти клиента. Следует помнить, что зачастую обработка результатов на клиенте проще, нежели средствами сервера.

mysqli_num_rows
---------------
mysqli_result::$num_rows -- mysqli_num_rows — Получает число рядов в результирующей выборке

Объектно-ориентированный стиль
------------------------------
int $mysqli_result->num_rows;
Процедурный стиль
------------------
int mysqli_num_rows ( mysqli_result $result )

Возвращает число рядов в результирующей выборке.

Поведение функции mysqli_num_rows() зависит от того, используется ли буферизованная или не буферизованная результирующая выборка. Для не буферизованной выборки mysqli_num_rows() не вернет правильное число рядов пока все ряды не будут получены и обработаны.

- result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().
- Возвращает число рядов в результирующей выборке.
- Если число рядов больше чем PHP_INT_MAX, то число будет возвращено в виде строки.

mysqli_data_seek
----------------
mysqli_result::data_seek -- mysqli_data_seek — Перемещает указатель результата на выбранную строку

Объектно-ориентированный стиль
------------------------------
bool mysqli_result::data_seek ( int $offset )
Процедурный стиль
-----------------
bool mysqli_data_seek ( mysqli_result $result , int $offset )
Функция mysqli_data_seek() перемещает указатель в результате на строку, указанную в параметре offset.

result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().

offset - Смещение. Должно быть между нулем и числом строк в результате минус один (0..mysqli_num_rows() - 1).

Возвращает TRUE в случае успешного завершения или FALSE в случае возникновения ошибки.

Эта функция может быть использована только с буферизованными результатами, которые можно получить использованием функций mysqli_store_result() или mysqli_query().

mysqli_fetch_assoc
------------------
mysqli_result::fetch_assoc -- mysqli_fetch_assoc — Извлекает результирующий ряд в виде ассоциативного массива

Объектно-ориентированный стиль
------------------------------
array mysqli_result::fetch_assoc ( void )
Процедурный стиль
------------------
array mysqli_fetch_assoc ( mysqli_result $result )
Возвращает ассоциативный массив, соответствующий результирующей выборке или NULL, если других рядов не существует.

Имена полей, возвращаемые этой функцией являются регистро-зависимыми.
Эта функция устанавливает NULL-поля в значение NULL PHP.

result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().

Возвращает ассоциативный массив строк, соответствующий результирующей выборке, где каждый ключ в массиве соответствует имени одного из столбцов выборки или NULL, если других рядов не существует.

Если два или более столбца в выборке имеют одинаковое название полей, то приоритет отдается последнему столбцу. Для доступа к другому столбцу с таким же именем вам необходимо произвести нумерованную выборку с помощью функцию mysqli_fetch_row() или добавить псевдонимы.

mysqli_fetch_row
----------------
mysqli_result::fetch_row -- mysqli_fetch_row — Получение строки результирующей таблицы в виде массива

Объектно-ориентированный стиль
------------------------------
mixed mysqli_result::fetch_row ( void )
Процедурный стиль
-----------------
mixed mysqli_fetch_row ( mysqli_result $result )
Выбирает одну строку данных из результирующего набора и возвращает ее в виде массива, в котором индексы элементов соответствуют номерам столбцов (начиная с 0). Каждый последующий вызов функции будет возвращать массив с данными следующей строки набора или NULL, если строки закончились.

result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().

mysqli_fetch_row() возвращает массив строк, соответствующих данным в выбранной строке результирующей таблицы, или NULL, если доступных строк больше нет.

Эта функция устанавливает NULL-поля в значение NULL PHP.

mysqli_fetch_array
------------------
mysqli_result::fetch_array -- mysqli_fetch_array — Выбирает одну строку из результирующего набора и помещает ее в ассоциативный массив, обычный массив или в оба

Объектно-ориентированный стиль
------------------------------
mixed mysqli_result::fetch_array ([ int $resulttype = MYSQLI_BOTH ] )
Процедурный стиль
------------------
mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] )
Возвращает массив соответствующий выбранной строке или NULL, если в результирующей таблице, представленной параметром result, больше нет доступных строк.

mysqli_fetch_array() является расширенной версией функции mysqli_fetch_row(). В добавок к сохранению данных в обычном массиве, mysqli_fetch_array() может сохранять строки в ассоциативном массиве, где имена полей результирующей таблицы будут ключами элементов.

Имена полей, возвращаемые этой функцией являются регистро-зависимыми.
Эта функция устанавливает NULL-поля в значение NULL PHP.
Если два столбца или более имеют одинаковые имена, данные последнего столбца будут перезаписывать данные предыдущих. В таких ситуациях для доступа к данным всех столбцов с одинаковыми именами лучше пользоваться обычными массивами, индексированными номерами столбцов.

result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().

resulttype - Этот необязательный параметр принимает значение константы, которая указывает на тип массива, в который требуется поместить данные. Возможные значения параметра: MYSQLI_ASSOC, MYSQLI_NUM или MYSQLI_BOTH.

При использовании константы MYSQLI_ASSOC функция будет вести себя идентично mysqli_fetch_assoc(), а при MYSQLI_NUM идентично функции mysqli_fetch_row(). При задании MYSQLI_BOTH функция создаст один массив, включающий атрибуты обоих вариантов.

Возвращает массив строк соответствующих выбранной строке набора или NULL, если в результирующей таблице больше нет данных.

mysqli_fetch_object
-------------------
mysqli_result::fetch_object -- mysqli_fetch_object — Возвращает текущую строку результирующего набора в виде объекта

Объектно-ориентированный стиль
------------------------------
object mysqli_result::fetch_object ([ string $class_name = "stdClass" [, array $params ]] )
Процедурный стиль
-----------------
object mysqli_fetch_object ( mysqli_result $result [, string $class_name = "stdClass" [, array $params ]] )
mysqli_fetch_object() вернет текущую строку результирующей таблицы в виде объекта, атрибуты которого будут соответствовать именам столбцов таблицы.

Важно заметить, что mysqli_fetch_object() задает значения свойств объекта до вызова его конструктора.

result - Только для процедурного стиля: Идентификатор результата запроса, полученный с помощью mysqli_query(), mysqli_store_result() или mysqli_use_result().
class_name - Имя класса, объект которого требуется инстанцировать, задать значения его свойств и вернуть. Если параметр не задан, будет возвращен объект stdClass.
params - Необязательный массив (array) параметров, которые будут переданы конструктору класса class_name.

Возвращает объект со строковыми свойствами, соответствующими значениям в выбранной строке или NULL, если в результирующем наборе нет доступных строк.

Имена полей, возвращаемые этой функцией являются регистро-зависимыми.
Эта функция устанавливает NULL-поля в значение NULL PHP.

Навигация по строкам буферизованной результирующей таблицы
-----------------------------------------------------------
select.php
----------
        <?php
        $mysqli = new mysqli(DBHOST, DBUSER, DBPASS, DBNAME);
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
        }

        $res = $mysqli->query("SELECT id, title FROM blog_posts ORDER BY id ASC");

        echo "Обратный порядок...\n";
        for ($row_no = $res->num_rows - 1; $row_no >= 0; $row_no--) {
            $res->data_seek($row_no);
            $row = $res->fetch_assoc();
            echo " id = " . $row['id'] . "\n";
            echo " title = " . $row['title'] . "\n";
        }

        echo "Исходный порядок строк...\n";
        $res->data_seek(0);
        while ($row = $res->fetch_assoc()) {
            echo " id = " . $row['id'] . "\n";
            echo " title = " . $row['title'] . "\n";
        }
        ?>

Небуферизуемые результирующие наборы
------------------------------------
Если клиентские ресурсы ограничены, и в тоже время не требуется поддерживать низкую нагрузку на сервер, можно использовать не буферизованные результирующие наборы. Навигация по таким таблицам невозможна, потому что так или иначе должны быть обработаны все строки набора.

Навигация по строкам не буферизованной результирующей таблицы
notbuf.php
----------
        <?php
        $mysqli->real_query("SELECT id, title FROM blog_posts ORDER BY id ASC");
        $res = $mysqli->use_result();

        echo "Порядок строк в результирующем наборе...\n";
        while ($row = $res->fetch_assoc()) {
            echo " id = " . $row['id'] . "\n";
            echo " title = " . $row['title'] . "\n";
        }
        ?>
Типы данных значений в результирующей таблице
---------------------------------------------
Функции mysqli_query(), mysqli_real_query() и mysqli_multi_query() предназначены для выполнения не подготавливаемых запросов. На уровне протокола клиент-серверного взаимодействия MySQL за выполнение запросов отвечают команда COM_QUERY и текстовый протокол. Когда используется текстовый протокол, сервер MySQL перед отправкой клиенту преобразует все данные в результирующем наборе в текстовые строки. Это преобразование выполняется вне зависимости от типа данных SQL столбца результирующей таблицы. Клиентские библиотеки mysql, в свою очередь, получают все данные, принимая их за строки. На клиенте не проводится никакого обратного преобразования к исходным типам, все данные, полученные приложением остаются PHP строками.

Текстовый протокол по умолчанию возвращает строки

text.php
--------

        <?php
        $mysqli = new mysqli(DBHOST, DBUSER, DBPASS, DBNAME);
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: (" . $mysqli->connect_errno . ") " . $mysqli->connect_error;
        }


        $res = $mysqli->query("SELECT id, title FROM blog_posts ORDER BY id ASC");
        $row = $res->fetch_assoc();

        printf("id = %s (%s)\n", $row['id'], gettype($row['id']));
        printf("title = %s (%s)\n", $row['title'], gettype($row['title']));

        ?>

Расширение Объекты данных PHP (PDO) 
===================================
определяет простой и согласованный интерфейс для доступа к базам данных в PHP. Каждый драйвер базы данных, в котором реализован этот интерфейс, может представить специфичный для базы данных функционал в виде стандартных функций расширения. Но надо заметить, что само по себе расширение PDO не позволяет манипулировать доступом к базе данных. Чтобы воспользоваться возможностями PDO, необходимо использовать соответствующий конкретной базе данныхPDO драйвер.

PDO обеспечивает абстракцию (доступа к данным). Это значит, что вне зависимости от того, какая конкретная база данных используется, вы можете пользоваться одними и теми функциями для выполнения запросов и выборки данных. PDO не абстрагирует саму базу данных, это расширение не переписывает SQL запросы и не эмулирует отсутствующий в СУБД функционал. Если нужно именно это, необходимо воспользоваться полноценной абстракцией базы данных.

Расширение PDO внедрено в PHP 5.1, но также доступно в 5.0 в виде PECL расширения; PDO использует новый OO функционал из ядра PHP 5, соответственно оно не будет работать с ранними версиями PHP.

Класс PDO 
=========
Представляет соединение между PHP и сервером базы данных.

Подключения и Управление подключениями 
--------------------------------------
Соединения устанавливаются автоматически при создании объекта PDO от его базового класса. Не имеет значения, какой драйвер вы хотите использовать; все что требуется, это имя базового класса. Конструктор класса принимает аргументы для задания источника данных (DSN), а также необязательные имя пользователя и пароль (если есть).
Подключение к MySQL
===================
        <?php
        //database credentials

            define('DBHOST','localhost');
            define('DBUSER','dev');
            define('DBPASS','ghbdtn');
            define('DBNAME','webdev');

            $db = new PDO("mysql:host=".DBHOST.";dbname=".DBNAME, DBUSER, DBPASS);
            $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

        ?>

В случае ошибки при подключении будет выброшено исключение PDOException. Его можно перехватить и обработать, либо оставить на откуп глобальному обработчику ошибок, который вы задали функцией set_exception_handler().

Обработка ошибок подключения
----------------------------
        <?php
        try {
          $stmt = $db->query('SELECT id, title, description, created FROM blog_posts ORDER BY id DESC');

          while($row = $stmt->fetch()){
              echo '<h2><a href="view.php?id='.$row['id'].'">'.$row['title'].'</a></h2>';
              echo '<p>Posted on '.date('jS M Y H:i:s', strtotime($row['created'])).'</p>';
              echo '<p>'.$row['description'].'</p>';       
              echo '<p><a href="view.php?id='.$row['id'].'">Read More</a></p>';       
          }
        } catch(PDOException $e) {
            echo $e->getMessage();
        }
        ?>

Если ваше приложение не перехватывает исключение PDO конструктора, движок zend выполнит стандартные операции для завершения работы скрипта и вывода обратной трассировки. В этой трассировке будет содержаться детальная информация о соединении с базой данных, включая имя пользователя и пароль. Ответственность за перехват исключений лежит на вас. 

Перехватить исключение можно явно (с помощью выражения catch), либо неявно, задав глобальный обработчик ошибок функцией set_exception_handler().
При успешном подключении к базе данных в скрипт будет возвращен созданный PDO объект. Соединение остается активным на протяжении всего времени жизни объекта. Чтобы закрыть соединение, необходимо уничтожить объект путем удаления всех ссылок на него (этого можно добиться, присваивая NULL всем переменным, указывающим на объект). Если не сделать этого явно, PHP автоматически закроет соединение по окончании работы скрипта.

Закрытие соединения
-------------------
        <?php
        $db = new PDO("mysql:host=".DBHOST.";dbname=".DBNAME, DBUSER, DBPASS);
        // здесь мы каким-то образом используем соединение
        // соединение больше не нужно, закрываем
        $db = null;
        ?>

Во многих приложениях может оказаться полезным использование постоянных соединений к базам данных. Постоянные соединения не закрываются при завершении работы скрипта, они кэшируются и используются повторно, когда другой скрипт запрашивает соединение с теми же учетными данными. Постоянные соединения позволяют избежать создания новых подключений каждый раз, когда требуется обмен данными с базой, что в результате дает прирост скорости работы таких приложений.

Постоянные соединения
---------------------
        <?php
        $db = new PDO("mysql:host=".DBHOST.";dbname=".DBNAME, DBUSER, DBPASS, array(
            PDO::ATTR_PERSISTENT => true
        ));
        ?>

PDO::ATTR_PERSISTENT
--------------------
Чтобы использовать постоянные соединения, необходимо добавить константу PDO::ATTR_PERSISTENT в массив параметров драйвера, который передается конструктору PDO. Если просто задать этот атрибут функцией PDO::setAttribute() уже после создания объекта, драйвер не будет использовать постоянные соединения.
Если вы используете PDO ODBC драйвер и ваши ODBC библиотеки поддерживают объединение подключений в пул (ODBC Connection Pooling) (unixODBC и Windows точно поддерживают, но могут быть и другие), то рекомендуется вместо постоянных соединений пользоваться этим пулом. Пул подключений ODBC доступен всем модулям текущего процесса; если PDO сам кэширует соединение, то это соединение будет недоступно другим модулям и не попадет в пул. В результате каждый модуль будет создавать дополнительные подключения для своих нужд.

PDO::query
===========
Выполняет SQL запрос и возвращает результирующий набор в виде объекта PDOStatement

    public PDOStatement PDO::query ( string $statement )
    public PDOStatement PDO::query ( string $statement , int $PDO::FETCH_COLUMN , int $colno )
    public PDOStatement PDO::query ( string $statement , int $PDO::FETCH_CLASS , string $classname , array $ctorargs )
    public PDOStatement PDO::query ( string $statement , int $PDO::FETCH_INTO , object $object )
    PDO::query() выполняет SQL запрос без подготовки и возвращает результирующий набор (если есть) в виде объекта PDOStatement.

Если запрос будет запускаться многократно, для улучшения производительности приложения имеет смысл этот запрос один раз подготовить методом PDO::prepare(), а затем запускать на выполнение методом PDOStatement::execute() столько раз, сколько потребуется.

Если после выполнения предыдущего запроса вы не выбрали все данные из результирующего набора, следующий вызов PDO::query() может потерпеть неудачу. В таких случаях следует вызывать метод PDOStatement::closeCursor(), который освободит ресурсы базы данных занятые предыдущим объектом PDOStatement. После этого можно безопасно вызывать PDO::query().

statement
=========
Текст SQL запроса для подготовки и выполнения.
Данные в запросе должны быть правильно экранированы.
Возвращаемые значения 
---------------------
PDO::query() возвращает объект PDOStatement или FALSE, если запрос выполнить не удалось.

Демонстрация работы PDO::query
------------------------------
После выполнения SELECT запроса можно сразу работать с результирующим набором посредством курсора.

        <?php
        <section class="row border-top border-bottom">
               <article class="content col-6">
               <?php
                try {
                  $stmt = $db->query('SELECT id, title, description, created FROM blog_posts ORDER BY id DESC');

                  while($row = $stmt->fetch()){
                      echo '<h2><a href="view.php?id='.$row['id'].'">'.$row['title'].'</a></h2>';
                      echo '<p>Posted on '.date('jS M Y H:i:s', strtotime($row['created'])).'</p>';
                      echo '<p>'.$row['description'].'</p>';       
                      echo '<p><a href="view.php?id='.$row['id'].'">Read More</a></p>';       
                  }
                } catch(PDOException $e) {
                    echo $e->getMessage();
                }
              ?>
            </article>
