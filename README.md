# web-dev

PHP
===
PHP (рекурсивный акроним словосочетания PHP: Hypertext Preprocessor) - это язык программирования общего назначения с открытым исходным кодом. PHP сконструирован специально для ведения Web-разработок и его код может внедряться непосредственно в HTML.


Пример Пример программирования на PHP

        <!DOCTYPE HTML>
        <html>
            <head>
                <title>Пример</title>
            </head>
            <body>

                <?php
                echo "Привет, я - скрипт PHP!";
                ?>

            </body>
        </html>

PHP содержит HTML с вкраплениями кода. Код PHP отделяется специальными начальным и конечным тегами <?php и ?>, которые позволяют "переключаться" в "PHP-режим" и выходить из него.

PHP отличается от JavaScript тем, что PHP-скрипты выполняются на сервере и генерируют HTML, который посылается клиенту. Если бы у вас на сервере был размещен скрипт, подобный вышеприведенному, клиент получил бы только результат его выполнения, но не смог бы выяснить, какой именно код его произвел. 

Переменные в PHP
================
определим, какой браузер использует тот, кто смотрит в данный момент нашу страницу. Для этого мы проверим строку с именем браузера, посылаемую нам в HTTP-запросе. Эта информация хранится в переменной. Переменные в PHP всегда предваряются знаком доллара. Интересующая нас в данный момент переменная называется $_SERVER['HTTP_USER_AGENT'].

$_SERVER - специальная зарезервированная переменная PHP, которая содержит всю информацию, полученную от Web-сервера. Её также называют суперглобальной.

Пример  Вывод значения переменной (элемента массива)
-------------------------------------------------------
        <?php
        echo $_SERVER['HTTP_USER_AGENT'];
        ?>

Внутрь PHP-тегов можно помещать несколько выражений и создавать маленькие блоки кода, делающие больше, чем простой вызов echo. Например, если вы хотите добавить проверку для Internet Explorer, можно сделать так:

Теги PHP
========
Когда PHP обрабатывает файл, он ищет открывающие и закрывающие теги, такие как <?php и ?>, которые указывают PHP, когда начинать и заканчивать обработку кода между ними. Подобный способ обработки позволяет PHP внедряться во все виды различных документов, так как всё, что находится вне пары открывающих и закрывающих тегов, будет проигнорировано парсером PHP.

PHP также допускает короткий открывающий тег <?, однако использовать их нежелательно, так как они доступны только если включены с помощью конфигурационной директивы php.ini short_open_tag, либо если PHP был сконфигурирован с опцией --enable-short-tags .

Если файл содержит только код PHP, предпочтительно опустить закрывающий тег в конце файла. Это помогает избежать добавлени случайных символов пробела или перевода строки после закрывающего тега PHP, которые могут послужить причиной нежелательных эффектов, так как PHP начинает выводить данные в буфер при отсутствии намерения у программиста выводить какие-либо данные в этой точке скрипта.

        <?php
        echo "Hello world";

        // ... еще код

        echo "Последнее выражение";

        // Скрипт заканчивается тут без закрывающего тега PHP

Изолирование от HTML
====================
Все, что находится вне пары открывающегося и закрывающегося тегов, игнорируется интерпретатором PHP, у которого есть возможность обрабатывать файлы со смешанным содержимым. Это позволяет PHP-коду быть встроенным в документы HTML, к примеру, для создания шаблонов.

        <p>Это будет проигнорировано PHP и отображено браузером.</p>
        <?php echo 'А это будет обработано.'; ?>
        <p>Это тоже будет проигнорировано PHP и отображено браузером.</p>


Использование структур с условиями
-----------------------------------
Пример Продвинутое изолирование с использованием условий

        <?php if ($expression == true): ?>
          Это будет отображено, если выражение истинно.
        <?php else: ?>
          В ином случае будет отображено это.
        <?php endif; ?>

В этом примере PHP пропускает блоки, где условие не соблюдается. Даже несмотря на то, что они находятся вне пары открывающих/закрывающих тегов, PHP пропустит их в соответствии с условием, так как интерпретатор PHP будет перепрыгивать через блоки, содержащиеся внутри условия, которое не соблюдается.

Пример Открывающие и закрывающие теги PHP

         <?php echo 'если вы хотите хранить код PHP в документах XHTML или XML,
                        то используйте эти теги'; ?>

         <script language="php">
                echo 'некоторые редакторы (например, FrontPage) не
                      любят инструкции обработки с этими тегами';
         </script>

         <? echo 'этот код с короткими тегами'; ?>
            Код с такими тегами <?= 'какой-нибудь текст' ?> является сокращением от <? echo 'какой-нибудь текст' ?>

         <% echo 'Также вы можете использовать теги в ASP стиле'; %>
    

Разделение инструкций 
---------------------
PHP требует окончания инструкций точкой запятой в конце каждой инструкции. Закрывающий тег блока PHP-кода автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с PHP-кодом. Закрывающий тег блока "поглотит" немедленно следующий за ним переход на новую строку, если таковой будет обнаружен.

        <?php
            echo 'Это тест';
        ?>

        <?php echo 'Это тест' ?>

        <?php echo 'Мы опустили последний закрывающий тег';

Комментарии 
-----------
PHP поддерживает комментарии в стиле 'C', 'C++' и оболочки Unix (стиль Perl). Например:

        <?php
            echo "Это тест"; // Это однострочный комментарий в стиле c++
            /* Это многострочный комментарий
               еще одна строка комментария */
            echo "Это еще один тест";
            echo "Последний тест"; # Это комментарий в стиле оболочки Unix
        ?>
Однострочные комментарии идут только до конца строки или текущего блока PHP-кода, в зависимости от того, что идет перед ними. 

        <h1>Это <?php # echo "простой";?> пример</h1>
        <p>Заголовок вверху выведет 'Это пример'.</p>
'C'-комментарии заканчиваются при первой же обнаруженной последовательности */. Убедитесь, что вы не вкладываете друг в друга 'C'-комментарии. Очень легко допустить эту ошибку при комментировании большого блока кода.

        <?php
         /*
            echo "Это тест"; /* Этот комментарий вызовет проблему */
         */
        ?>

Переменные в PHP
================
Переменные в PHP представлены знаком доллара с последующим именем переменной. Имя переменной чувствительно к регистру.

Имена переменных соответствуют тем же правилам, что и остальные наименования в PHP. Правильное имя переменной должно начинаться с буквы или символа подчеркивания и состоять из букв, цифр и символов подчеркивания в любом количестве. Это можно отобразить регулярным выражением: 

        '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'

Под буквами здесь подразумеваются символы a-z, A-Z, и байты от 127 до 255 (0x7f-0xff).
$this - это особая переменная, которой нельзя ничего присваивать.


        <?php
        $var = 'Bob';
        $Var = 'Joe';
        echo "$var, $Var";      // выведет "Bob, Joe"

        $4site = 'not yet';     // неверно; начинается с цифры
        $_4site = 'not yet';    // верно; начинается с символа подчеркивания
        $täyte = 'mansikka';    // верно; 'ä' это (Расширенный) ASCII 228.
        ?>
По умолчанию, переменные всегда присваиваются по значению. То есть, когда вы присваиваете выражение переменной, все значение оригинального выражения копируется в эту переменную. Это означает, что после того как одной переменной присвоено значение другой, изменение одной из них не влияет на другую.

PHP также предлагает иной способ присвоения значений переменным: присвоение по ссылке. Это означает, что новая переменная просто ссылается (иначе говоря, "становится псевдонимом" или "указывает") на оригинальную переменную. Изменения в новой переменной отражаются на оригинале, и наоборот.

Для присвоения по ссылке, просто добавьте амперсанд (&) к началу имени присваиваемой (исходной) переменной. Например, следующий фрагмент кода дважды выводит 'Меня зовут Боб':

        <?php
        $foo = 'Боб';              // Присваивает $foo значение 'Боб'
        $bar = &$foo;              // Ссылка на $foo через $bar.
        $bar = "Меня зовут $bar";  // Изменение $bar...
        echo $bar;
        echo $foo;                 // меняет и $foo.
        ?>
Важно отметить, что по ссылке могут быть присвоены только именованные переменные.

        <?php
        $foo = 25;
        $bar = &$foo;      // Это верное присвоение.
        $bar = &(24 * 7);  // Неверно; ссылка на неименованное выражение.

        function test()
        {
           return 25;
        }

        $bar = &test();    // Неверно.
        ?>
Хотя в PHP и нет необходимости инициализировать переменные, это считается очень хорошей практикой. Неинициализированные переменные принимают значение по умолчанию в зависимости от их типа, который определяется из контекста их первого использования: булевы принимают значение FALSE, целые и числа с плавающей точкой - ноль, строки (например, при использовании в echo) - пустую строку, а массивы становятся пустыми массивами.

Пример Значения по умолчанию в неинициализированных переменных

        <?php
        // Неустановленная И не имеющая ссылок (т.е. без контекста использования) переменная; выведет NULL
        var_dump($unset_var);

        // Булевое применение; выведет 'false' (Подробнее по этому синтаксису смотрите раздел о тернарном операторе)
        echo($unset_bool ? "true\n" : "false\n");

        // Строковое использование; выведет 'string(3) "abc"'
        $unset_str .= 'abc';
        var_dump($unset_str);

        // Целочисленное использование; выведет 'int(25)'
        $unset_int += 25; // 0 + 25 => 25
        var_dump($unset_int);

        // Использование в качестве числа с плавающей точкой (float/double); выведет 'float(1.25)'
        $unset_float += 1.25;
        var_dump($unset_float);

        // Использование в качестве массива; выведет array(1) {  [3]=>  string(3) "def" }
        $unset_arr[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
        var_dump($unset_arr);

        // Использование в качестве объекта; создает новый объект stdClass (см. http://www.php.net/manual/en/reserved.classes.php)
        // Выведет: object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
        $unset_obj->foo = 'bar';
        var_dump($unset_obj);
        ?>

Для обнаружения инициализации переменной может быть использована языковая конструкция isset().

Константы 
=========

Константы - это идентификаторы (имена) простых значений, их значение не может изменяться в ходе выполнения скрипта. Имена констант чувствительны к регистру. По принятому соглашению, имена констант всегда пишутся в верхнем регистре.

Имя константы должно соответствовать тем же правилам, что и другие имена в PHP. Правильное имя начинается с буквы или символа подчеркивания и состоит из букв, цифр и подчеркиваний. Регулярное выражение для проверки правильности имени константы выглядит так: 

    [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*


Пример Правильные и неправильные имена констант

        <?php

        // Правильные имена констант
        define("FOO",     "something");
        define("FOO2",    "something else");
        define("FOO_BAR", "something more");

        // Неправильные имена констант
        define("2FOO",    "something");

        // Это корректное объявление, но лучше его не использовать:
        // PHP однажды может зарегистрировать "волшебную" константу,
        // которая сломает ваш скрипт
        define("__FOO__", "something");

        ?>

Волшебные константы 
====================
PHP предоставляет большой список предопределенных констант для каждого выполняемого скрипта. Многие из этих констант определяются различными модулями и будут присутствовать только в том случае, если эти модули доступны в результате динамической загрузки или в результате статической сборки.

Есть восемь волшебных констант, которые меняют свое значение в зависимости от контекста, в котором они используются. Например, значение __LINE__ зависит от строки в скрипте, на которой эта константа указана. Специальные константы нечувствительны к регистру и их список приведен ниже:

волшебные константы PHP
-----------------------

__LINE__    Текущий номер строки в файле.

__FILE__    Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.

__DIR__ Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.

__FUNCTION__    Имя функции.

__CLASS__   Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). Обратите внимание, что начиная с PHP5.4 __CLASS__ также работает в трейтах. При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.

__TRAIT__   Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).

__METHOD__  Имя метода класса.

__NAMESPACE__   Имя текущего пространства имен.

Выражения 
==========
Основными формами выражений являются константы и переменные. Если вы записываете "$a = 5", вы присваиваете '5' переменной $a. '5'.

После этого присвоения вы ожидаете, что значением $a также является 5, поэтому, если вы написали $b = $a, вы полагаете, что работать это будет так же, как если бы вы написали $b = 5.

примерами выражений являются функции:

        <?php
        function foo ()
        {
            return 5;
        }
        ?>

include 
========
Выражение include включает и выполняет указанный файл.

Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве include_path. Если файл не найден в include_path, include попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция include выдаст warning, если не сможет найти файл; поведение отлично от require, который выдаст фатальную ошибку.

Если путь указан — не важно, абсолютный (начинающийся с буквы диска или с \ в Windows или с / в Unix/Linux системах) или относительно текущей директории (начинающийся с . или ..) — директива include_path будет проигнорирована в любом случае. К примеру, если начинается с ../, парсер проверит родительскую директорию на наличие запрошенного файла.

Когда файл включается, его код наследует ту же область видимости переменных, что и строка, на которой произошло включение. Все переменные, доступные на этой строке во включающем файле будут также доступны во включаемом файле. Однако все функции и классы, объявленные во включаемом файле, будут доступны в глобальной области видимости.

Простой пример include

        vars.php
        <?php

        $color = 'green';
        $fruit = 'apple';

        ?>

        test.php
        <?php

        echo "A $color $fruit"; // A

        include 'vars.php';

        echo "A $color $fruit"; // A green apple

        ?>
Если включение происходит внутри функции включающего файла, тогда весь код, содержащийся во включаемом файле, будет вести себя так, как будто он был определен внутри этой функции. То есть, он будет в той же области видимости переменных этой функции. Исключением к этому правилу являются магические константы, которые выполняются парсером перед тем, как происходит включение.

require 
=======

require идентично include за исключением того, что при ошибке оно также выдаст фатальную ошибку уровня E_COMPILE_ERROR - остановит выполнение скрипта, тогда как include только выдала бы предупреждение E_WARNING, которое позволило бы скрипту продолжить выполнение.

include_once 
=============

Выражение include_once включает и выполняет указанный файл во время выполнения скрипта. Его поведение идентично выражению include, с той лишь разницей, что если код из файла уже один раз был включен, он не будет включен и выполнен повторно. Как видно из имени, он включит файл только один раз (include once).

include_once может использоваться в тех случаях, когда один и тот же файл может быть включен и выполнен более одного раза во время выполнения скрипта, в данном случае это поможет избежать проблем с переопределением функций, переменных и т.д.

require_once 
============
Выражение require_once идентично require за исключением того, что PHP проверит, включался ли уже данный файл, и, если да, не будет включать его еще раз.

Оператор
========
Оператором называется нечто, принимающее одно или более значений (или выражений), и вычисляющее новое значение.

Приоритет оператора 
===================
Приоритет оператора определяет, насколько "тесно" он связывает между собой два выражения. Например, выражение 1 + 5 * 3 вычисляется как 16, а не 18, поскольку оператор умножения ("*") имеет более высокий приоритет, чем оператор сложения ("+"). Круглые скобки могут использоваться для принудительного указания порядка выполнения операторов. Например, выражение (1 + 5) * 3 вычисляется как 18.

Если операторы имеют равный приоритет, то их группирование определяется их ассоциативностью. Например "-" имеет левую ассоциативность, поэтому 1 - 2 - 3 группируется как (1 - 2) - 3 и равно -4. С другой стороны, "=" имеет правую ассоциативность, поэтому $a = $b = $c группируется как $a = ($b = $c).

Операторы с равным приоритетом, но не имеющие ассоциативность, не могут использоваться вслед друг за другом, например 1 < 2 > 1 недопустимо в PHP. С другой стороны, выражение 1 <= 1 == 1 вполне допустимо, так как оператор == имеет меньший приоритет чем оператор <=.

Используйте скобки, даже если они не обязательны. Чаще всего это повышает читаемость кода, непосредственно определяя порядок группировки, не полагаясь на конкретные приоритет или ассоциативность оператора.

Порядок выполнения операторов
-----------------------------

        неассоциативна  clone new   clone и new
        левая   [   array()
        правая  **  арифметика
        правая  ++ -- ~ (int) (float) (string) (array) (object) (bool) @    типы и инкремент/декремент
        неассоциативна  instanceof  типы
        правая  !   логические операторы
        левая   * / %   арифметические операторы
        левая   + - .   арифметические операторы и строковые операторы
        левая   << >>   побитовые операторы
        неассоциативна  < <= > >=   операторы сравнения
        неассоциативна  == != === !== <>    операторы сравнения
        левая   &   побитовые операторы и ссылки
        левая   ^   побитовые операторы
        левая   |   побитовые операторы
        левая   &&  логические операторы
        левая   ||  логические операторы
        левая   ? : тернарный оператор
        правая  = += -= *= **= /= .= %= &= |= ^= <<= >>= => операторы присваивания
        левая   and логические операторы
        левая   xor логические операторы
        левая   or  логические операторы
        левая   ,   множество применений

Арифметические операторы 
========================

        -$a Отрицание   Смена знака $a.
        $a + $b Сложение    Сумма $a и $b.
        $a - $b Вычитание   Разность $a и $b.
        $a * $b Умножение   Произведение $a и $b.
        $a / $b Деление Частное от деления $a на $b.
        $a % $b Деление по модулю   Целочисленный остаток от деления $a на $b.
        $a ** $b    Возведение в степень    Результат возведения $a в степень $b.

Операция деления ("/") возвращает число с плавающей точкой, кроме случая, когда оба значения являются целыми числами (или строками, которые преобразуются в целые числа), которые делятся нацело - в этом случае возвращается целое значение.

При делении по модулю операнды преобразуются в целые числа (удалением дробной части) до начала операции.

Результат операции остатка от деления % будет иметь тот же знак, что и делимое — то есть, результат $a % $b будет иметь тот же знак, что и $a. Например:

        <?php

        echo (5 % 3)."\n";           // выводит 2
        echo (5 % -3)."\n";          // выводит 2
        echo (-5 % 3)."\n";          // выводит -2
        echo (-5 % -3)."\n";         // выводит -2

        ?>

Оператор присваивания 
=====================
Базовый оператор присваивания обозначается как "=". оператор присваивания означает, что левый операнд получает значение правого выражения, (т.е. устанавливается значением).

Результатом выполнения оператора присваивания является само присвоенное значение. Таким образом, результат выполнения "$a = 3" будет равен 3. Это позволяет делать трюки наподобие:

        <?php

        $a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.

        ?>

Операторы инкремента и декремента
==================================
PHP поддерживает префиксные и постфиксные операторы инкремента и декремента в стиле C.

Операторы инкремента/декремента влияют только на строки и числа. Массивы, объекты и ресурсы не трогаются. Декремент NULL также не даст никакого эффекта, однако инкремент даст значение 1.

Операторы инкремента и декремента
---------------------------------
        ++$a    Префиксный инкремент    Увеличивает $a на единицу, затем возвращает значение $a.
        $a++    Постфиксный инкремент   Возвращает значение $a, затем увеличивает $a на единицу.
        --$a    Префиксный декремент    Уменьшает $a на единицу, затем возвращает значение $a.
        $a--    Постфиксный декремент   Возвращает значение $a, затем уменьшает $a на единицу.

Приведем:

        <?php
        echo "<h3>Постфиксный инкремент</h3>";
        $a = 5;
        echo "Должно быть 5: " . $a++ . "<br />\n";
        echo "Должно быть 6: " . $a . "<br />\n";

        echo "<h3>Префиксный инкремент</h3>";
        $a = 5;
        echo "Должно быть 6: " . ++$a . "<br />\n";
        echo "Должно быть 6: " . $a . "<br />\n";

        echo "<h3>Постфиксный декремент</h3>";
        $a = 5;
        echo "Должно быть 5: " . $a-- . "<br />\n";
        echo "Должно быть 4: " . $a . "<br />\n";

        echo "<h3>Префиксный декремент</h3>";
        $a = 5;
        echo "Должно быть 4: " . --$a . "<br />\n";
        echo "Должно быть 4: " . $a . "<br />\n";
        ?>


пример префиксного и постфиксного инкремента и выражений:

        <?php
        function double($i)
        {
            return $i*2;
        }
        $b = $a = 5;        /* присвоить значение пять переменным $a и $b */
        $c = $a++;          /* постфиксный инкремент, присвоить значение $a 
                               (5) переменной $c */
        $e = $d = ++$b;     /* префиксный инкремент, присвоить увеличенное
                               значение $b (6) переменным $d и $e */

        /* в этой точке и $d, и $e равны 6 */

        $f = double($d++);  /* присвоить удвоенное значение $d перед
                               инкрементом (2*6 = 12) переменной $f */
        $g = double(++$e);  /* присвоить удвоенное значение $e после
                               инкремента (2*7 = 14) переменной $g */
        $h = $g += 10;      /* сначала переменная $g увеличивается на 10,
                               приобретая, в итоге, значение 24. Затем значение
                               присвоения (24) присваивается переменной $h,
                               которая в итоге также становится равной 24. */
        ?>


Булев тип
=========
boolean выражает истинность значения. Он может быть либо TRUE, либо FALSE.

Для указания boolean, используйте константы TRUE или FALSE. Обе они регистронезависимы.

        <?php
        $foo = True; // присвоить $foo значение TRUE
        ?>
Обычно, некоторый оператор возвращает boolean значение, которое потом передается управляющей конструкции.

        <?php
        // == это оператор, который проверяет
        // эквивалентность и возвращает boolean
        if ($action == "show_version") {
            echo "The version is 1.23";
        }

        // это необязательно...
        if ($show_separators == TRUE) {
            echo "<hr>\n";
        }

        // ... потому что следующее имеет тот же самый смысл:
        if ($show_separators) {
            echo "<hr>\n";
        }
        ?>
Преобразование в булев тип 
--------------------------
Для явного преобразования в boolean, используйте (bool) или (boolean). Однако, в большинстве случаев приведение типа необязательно, так как значение будет автоматически преобразовано, если оператор, функция или управляющая конструкция требует boolean аргумент.

При преобразовании в boolean, следующие значения рассматриваются как FALSE:

        само значение boolean FALSE
        integer 0 (ноль)
        float 0.0 (ноль)
        пустая строка, и строка "0"
        массив без элементов
        особый тип NULL (включая неустановленные переменные)
        Объекты SimpleXML, созданные из пустых тегов
        Все остальные значения рассматриваются как TRUE (включая любой resource).

-1 рассматривается как TRUE, как и любое другое ненулевое (отрицательное или положительное) число!
        <?php
        var_dump((bool) "");        // bool(false)
        var_dump((bool) 1);         // bool(true)
        var_dump((bool) -2);        // bool(true)
        var_dump((bool) "foo");     // bool(true)
        var_dump((bool) 2.3e5);     // bool(true)
        var_dump((bool) array(12)); // bool(true)
        var_dump((bool) array());   // bool(false)
        var_dump((bool) "false");   // bool(true)
        ?>

Операторы сравнения 
===================
Операторы сравнения позволяют сравнивать между собой два значения. 


        $a == $b    Равно   TRUE если $a равно $b после преобразования типов.
        $a === $b   Тождественно равно  TRUE если $a равно $b и имеет тот же тип.
        $a != $b    Не равно    TRUE если $a не равно $b после преобразования типов.
        $a <> $b    Не равно    TRUE если $a не равно $b после преобразования типов.
        $a !== $b   Тождественно не равно   TRUE если $a не равно $b или они разных типов.
        $a < $b Меньше  TRUE если $a строго меньше $b.
        $a > $b Больше  TRUE если $a строго больше $b.
        $a <= $b    Меньше или равно    TRUE если $a меньше или равно $b.
        $a >= $b    Больше или равно    TRUE если $a больше или равно $b.

Сравнение булево/null
----------------------
        <?php
        // Булево и null всегда сравниваются как булево значение 
        var_dump(1 == TRUE);  // TRUE - тоже что и (bool)1 == TRUE
        var_dump(0 == FALSE); // TRUE - тоже что и (bool)0 == FALSE
        var_dump(100 < TRUE); // FALSE - тоже что и (bool)100 < TRUE
        var_dump(-10 < FALSE);// FALSE - тоже что и (bool)-10 < FALSE
        var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 , тоже что и FALSE < TRUE
        ?>

Логические операторы 
====================

        $a and $b   И   TRUE если и $a, и $b TRUE.
        $a or $b    Или TRUE если или $a, или $b TRUE.
        $a xor $b   Исключающее или TRUE если $a, или $b TRUE, но не оба.
        ! $a    Отрицание   TRUE если $a не TRUE.
        $a && $b    И   TRUE если и $a, и $b TRUE.
        $a || $b    Или TRUE если или $a, или $b TRUE.

Смысл двух разных вариантов для операторов "and" и "or" в том, что они работают с различными приоритетами.

Пример Объяснение логических операторов

        <?php

        // --------------------
        // foo() никогда не буде вызвана, так как эти операторы являются шунтирующими (short-circuit)

        $a = (false && foo());
        $b = (true  || foo());
        $c = (false and foo());
        $d = (true  or  foo());

        // --------------------
        // "||" имеет больший приоритет, чем "or"

        // Результат выражения (false || true) присваивается переменной $e
        // Действует как: ($e = (false || true))
        $e = false || true;

        // Константа false присваивается $f, а затем значение true игнорируется
        // Действует как: (($f = false) or true)
        $f = false or true;

        var_dump($e, $f);

        // --------------------
        // "&&" имеет больший приоритет, чем "and"

        // Результат выражения (true && false) присваивается переменной $g
        // Действует как: ($g = (true && false))
        $g = true && false;

        // Константа true присваивается $h, а затем значение false игнорируется
        // Действует как: (($h = true) and false)
        $h = true and false;

        var_dump($g, $h);
        ?>

if 
===

        if (выражение)
          инструкция

выражение вычисляется в булево значение. Если выражение принимает значение TRUE, PHP выполнит инструкцию, а если оно принимает значение FALSE - проигнорирует. 

Следующий пример выведет a больше b, если значение переменной $a больше, чем $b:

        <?php
        if ($a > $b)
          echo "a больше b";
        ?>

Часто необходимо, чтобы условно выполнялось более одной инструкции.  

можно объединить несколько инструкций в блок:

        <?php
        if ($a > $b) {
          echo "a больше b";
          $b = $a;
        }
        ?>
Инструкции if могут быть бесконечно вложены в другие инструкции if, что даёт большую гибкость в организации условного выполнения различных частей программы.

else 
====

Часто необходимо выполнить одно выражение, если определенное условие верно, и другое выражение, если условие не верно. Именно для этого else и используется. else расширяет оператор if, чтобы выполнить выражение, в случае если условие в операторе if равно FALSE. К примеру, следующий код выведет a больше чем b, если $a больше, чем $b, и a НЕ больше, чем b в противном случае:

        <?php
        if ($a > $b) {
          echo "a больше, чем b";
        } else {
          echo "a НЕ больше, чем b";
        }
        ?>
Выражение else выполняется только, если выражение if эквивалентно FALSE, и если нет других любых выражений elseif, или если они все равны FALSE также.

elseif/else if 
==============
Конструкция elseif, как ее имя и говорит есть сочетание if и else. Аналогично else, она расширяет оператор if для выполнения различных выражений в случае, когда условие начального оператора if эквивалентно FALSE. Однако, в отличии от else, выполнение альтернативного выражения произойдет только тогда, когда условие оператора elseif будет являться равным TRUE. К примеру, следующий код может выводить a больше, чем b, a равно b or a меньше, чем b:

        <?php
        if ($a > $b) {
            echo "a больше, чем b";
        } elseif ($a == $b) {
            echo "a равен b";
        } else {
            echo "a меньше, чем b";
        }
        ?>
Может быть несколько elseif в одном if выражении. Первое же выражение elseif (если будет хоть одно) равное TRUE будет выполнено. В PHP вы также можете написать 'else if' (в два слова), и тогда поведение будет идентичным 'elseif' (в одно слово). Синтаксически значение немного отличается, но в конечном итоге оба выражения приведут к одному и тому же результату.

Выражение elseif выполнится, если предшествующее выражение if и предшествующие выражения elseif эквивалентны FALSE, а текущий elseif равен TRUE.

elseif и else if будут равнозначны только при использовании фигурных скобок, как в примерах выше. Если используются двоеточие для определения условий if/elseif, Вы не должны разделять else if в два слова, иначе это вызовет фатальную ошибку в PHP.

        <?php

        /* Некорректный способ: */
        if($a > $b):
            echo $a." больше, чем ".$b;
        else if($a == $b): // Не скомпилируется.
            echo "Строка выше вызывает фатальную ошибку.";
        endif;


        /* Корректный способ: */
        if($a > $b):
            echo $a." больше, чем ".$b;
        elseif($a == $b): // Заметьте, тут одно слово.
            echo $a." равно ".$b;
        else:
            echo $a." не больше и не равно ".$b;
        endif;

        ?>

Тернарный оператор "?:"
=======================

Пример Присваивание значения по умолчанию

        <?php
        // Пример использования тернарного оператора
        $action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

        // Приведенный выше код аналогичен следующему блоку с использованием if/else
        if (empty($_POST['action'])) {
            $action = 'default';
        } else {
            $action = $_POST['action'];
        }

        ?>
Выражение (expr1) ? (expr2) : (expr3) интерпретируется как expr2, если expr1 имеет значение TRUE, или как expr3 если expr1 имеет значение FALSE.
Начиная с версии PHP 5.3 также стало возможным не писать среднюю часть тернарного оператора. Выражение expr1 ?: expr3 возвращает expr1 если expr1 имеет значение TRUE, и expr3 в другом случае.

тернарный оператор является выражением и трактуется не как переменная, а как результат выражения. Выражение return $var == 42 ? $a : $b; не будет работать в функции, возвращающей значение по ссылке, а в более поздних версиях PHP также будет выдано предупреждение.

Рекомендуется избегать "нагромождения" тернарных выражений. Поведение PHP неочевидно при использовании нескольких тернарных операторов в одном выражении:

Пример Неочевидное поведение тернарного оператора
        <?php
        // на первый взгляд, следующий код должен вывести 'true'
        echo (true?'true':false?'t':'f');

        // однако, он выводит 't'
        // это происходит потому, что тернарные выражения вычисляются слева направо

        // это намного более очевидная версия вышеприведенного кода
        echo ((true ? 'true' : false) ? 't' : 'f');

        // здесь вы можете видеть, что первое выражение вычисляется в 'true', которое
        // в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
        // второго тернарного выражения.
        ?>

оператор switch
---------------
В случае, если вы сравниваете число со строкой или две строки, содержащие числа, каждая строка будет преобразована в число, и сравниваться они будут как числа. Эти правила также распространяются на оператор switch. Преобразование типов не происходит при использовании === или !== так как в этом случае кроме самих значений сравниваются еще и типы.

        <?php
        var_dump(0 == "a"); // 0 == 0 -> true
        var_dump("1" == "01"); // 1 == 1 -> true
        var_dump("10" == "1e1"); // 10 == 10 -> true
        var_dump(100 == "1e2"); // 100 == 100 -> true

        switch ("a") {
        case 0:
            echo "0";
            break;
        case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
            echo "a";
            break;
        }
        ?>


Альтернативный синтаксис управляющих структур 
==============================================

PHP предлагает альтернативный синтаксис для некоторых его управляющих структур, а именно: if, while, for, foreach и switch. В каждом случае основной формой альтернативного синтаксиса является изменение открывающей фигурной скобки на двоеточие (:), а закрывающей скобки на endif;, endwhile;, endfor;, endforeach; или endswitch; соответственно.

        <?php if ($a == 5): ?>
        A равно 5
        <?php endif; ?>

блок HTML "A равно 5" вложен внутрь структуры if написанной с альтернативным синтаксисом. HTML блок будет показан только если переменная $a равна 5.

Альтернативный синтаксис также применяется и к else и elseif. Ниже приведена структура if с elseif и else в альтернативном формате:

        <?php
        if ($a == 5):
            echo "a равно 5";
            echo "...";
        elseif ($a == 6):
            echo "a равно 6";
            echo "!!!";
        else:
            echo "a не равно ни 5 ни 6";
        endif;
        ?>

Смешивание синтаксиса в одном и том же блоке управления не поддерживается.

Любой вывод (включая пробельные символы) между выражением switch и первым case приведут к синтаксической ошибке. Например этот код не будет работать:

        <?php switch ($foo): ?>
            <?php case 1: ?>
            ...
        <?php endswitch ?>

В то же время следующий пример будет работать, так как завершающий перевод строки после выражения switch считается частью закрывающего ?> и следовательно ничего не выводится между switch и case:
        <?php switch ($foo): ?>
        <?php case 1: ?>
            ...
        <?php endswitch ?>

Целые числа 
===========
Integer - это число из множества ℤ = {..., -2, -1, 0, 1, 2, ...}.

Целые числа могут быть указаны в десятичной (основание 10), шестнадцатеричной (основание 16), восьмеричной (основание 8) или двоичной (основание 2) системе счисления, с необязательным предшествующим знаком (- или +).

Для записи в восьмеричной системе счисления, необходимо поставить пред числом 0 (ноль). Для записи в шестнадцатеричной системе счисления, необходимо поставить перед числом 0x. Для записи в двоичной системе счисления, необходимо поставить перед числом 0b

Пример Целые числа

        <?php
        $a = 1234; // десятичное число
        $a = -123; // отрицательное число
        $a = 0123; // восьмеричное число (эквивалентно 83 в десятичной системе)
        $a = 0x1A; // шестнадцатеричное число (эквивалентно 26 в десятичной системе)
        $a = 0b11111111; // двоичное число (эквивалентно 255 в десятичной системе)
        ?>
Формально, структуру целых чисел можно записать так:

        десятичные        : [1-9][0-9]*
                          | 0

        шестнадцатеричные : 0[xX][0-9a-fA-F]+

        восьмеричные      : 0[0-7]+

        двоичные          : 0b[01]+

        целые             : [+-]?десятичные
                          | [+-]?шестнадцатеричные
                          | [+-]?восьмеричные
                          | [+-]?двоичные
Размер integer зависит от платформы, хотя, как правило, максимальное значение примерно равно 2 миллиардам (это 32-битное знаковое). 64-битные платформы обычно имеют максимальное значение около 9E18, кроме Windows, которая всегда 32-битная. PHP не поддерживает беззнаковые целые (integer). С версии PHP 4.4.0 и PHP 5.0.5 размер integer может быть определен с помощью константы PHP_INT_SIZE, а его максимальное значение - с помощью константы PHP_INT_MAX.

Если в восьмеричном integer будет обнаружена неверная цифра (например, 8 или 9), оставшаяся часть числа будет проигнорирована.

Пример Странности с восьмеричными числами

    <?php
    var_dump(01090); // 010 octal = 8 decimal
    ?>
Переполнение целых чисел
------------------------
Если PHP обнаружил, что число превышает размер типа integer, он будет интерпретировать его в качестве float. Аналогично, если результат операции лежит за границами типа integer, он будет преобразован в float.

Пример Переполнение целых на 32-битных системах

        <?php
        $large_number = 2147483647;
        var_dump($large_number);                     // int(2147483647)

        $large_number = 2147483648;
        var_dump($large_number);                     // float(2147483648)

        $million = 1000000;
        $large_number =  50000 * $million;
        var_dump($large_number);                     // float(50000000000)
        ?>
Пример Переполнение целых на 64-битных системах

        <?php
        $large_number = 9223372036854775807;
        var_dump($large_number);                     // int(9223372036854775807)

        $large_number = 9223372036854775808;
        var_dump($large_number);                     // float(9.2233720368548E+18)

        $million = 1000000;
        $large_number =  50000000000000 * $million;
        var_dump($large_number);                     // float(5.0E+19)
        ?>
В PHP не существует оператора деления целых чисел. Результатом 1/2 будет float 0.5. Если привести значение к integer, оно будет округлено вниз. Для большего контроля над округлением используйте функцию round().

        <?php
        var_dump(25/7);         // float(3.5714285714286) 
        var_dump((int) (25/7)); // int(3)
        var_dump(round(25/7));  // float(4) 
        ?>
Преобразование в целое 
----------------------
Для явного преобразования в integer, используйте приведение (int) или (integer). Однако, в большинстве случаев, в приведении типа нет необходимости, так как значение будет автоматически преобразовано, если оператор, функция или управляющая структура требует аргумент типа integer. Значение также может быть преобразовано в integer с помощью функции intval().

Если resource преобразуется в integer, то результатом будет уникальный номер ресурса, привязанный к resource во время исполнения PHP программы.

Из булевого типа 
-----------------
FALSE преобразуется в 0 (ноль), а TRUE - в 1 (единицу).

Из чисел с плавающей точкой 
---------------------------
При преобразовании из float в integer, число будет округлено в сторону нуля.

Если число с плавающей точкой превышает размеры integer (обычно +/- 2.15e+9 = 2^31 на 32-битных системах и +/- 9.22e+18 = 2^63 на 64-битных системах, кроме Windows), результат будет неопределенным, так как float не имеет достаточной точности, чтобы вернуть верный результат. В этом случае не будет выведено ни предупреждения, ни даже замечания!

Никогда не приводите неизвестную дробь к integer, так как это иногда может дать неожиданные результаты.
        <?php
        echo (int) ( (0.1+0.7) * 10 ); // выводит 7!
        ?>

Числа с плавающей точкой 
========================
Числа с плавающей точкой (также известные как "float", "double", или "real") могут быть определены следующими синтаксисами:

        <?php
        $a = 1.234; 
        $b = 1.2e3; 
        $c = 7E-10;
        ?>
Размер числа с плавающей точкой зависит от платформы, хотя максимум, как правило составляет ~1.8e308 с точностью около 14 десятичных цифр (64-битный IEEE формат).

Точность чисел с плавающей точкой
----------------------------------
Числа с плавающей точкой имеют ограниченную точность. Хотя это зависит от операционной системы, в PHP обычно используется формат двойной точности IEEE 754, дающий максимальную относительную ошибку округления порядка 1.11e-16. Неэлементарные арифметические операции могут давать большие ошибки, и, разумеется, необходимо принимать во внимание распространение ошибок при совместном использовании нескольких операций.
Кроме того, рациональные числа, которые могут быть точно представлены в виде чисел с плавающей точкой с основанием 10, например, 0.1 или 0.7, не имеют точного внутреннего представления в качестве чисел с плавающей точкой с основанием 2, вне зависимости от размера мантиссы. Поэтому они и не могут быть преобразованы в их внутреннюю двоичную форму без небольшой потери точности. Это может привести к неожиданным результатам: например, floor((0.1+0.7)*10) скорее всего вернет 7 вместо ожидаемого 8, так как результат внутреннего представления будет чем-то вроде 7.9999999999999991118....
Так что никогда не доверяйте точности чисел с плавающей точкой до последней цифры, и не проверяйте напрямую их равенство. Если вам действительно необходима высокая точность, используйте математические функции произвольной точности и gmp-функции.
"Простое" объяснение можно найти в » руководстве по числам с плавающей точкой, которое также называется "Why don’t my numbers add up?" ("Почему мои числа не складываются?")

Сравнение чисел с плавающей точкой 
----------------------------------

Для сравнения чисел с плавающей точкой используется верхняя граница относительной ошибки при округлении. Эта величина называется машинной эпсилон или единица округления(unit roundoff) и представляет собой самую маленькую допустимую разницу при расчетах.

$a и $b равны до 5-ти знаков после запятой.

        <?php
        $a = 1.23456789;
        $b = 1.23456780;
        $epsilon = 0.00001;

        if(abs($a-$b) < $epsilon) {
            echo "true";
        }
        ?>
NaN 
===
Некоторые числовые операции могут возвращать значение, представляемое константой NAN. Данный результат означает неопределенное или непредставимое значение в операциях с плавающей точкой. Любое строгое или нестрогое сравнение данного значения с другим значением, включая его самого, возвратит FALSE.

Так как NAN представляет собой неограниченное количество различных значений, то NAN не следует сравнивать с другими значениями, включая ее саму. Вместо этого, для определения ее наличия необходимо использовать функцию is_nan().


Строки 
======
Строка - это набор символов, где символ - это то же самое, что и байт. Это значит, что PHP поддерживает ровно 256 различных символов, а также то, что в PHP нет встроенной поддержки Unicode.

Строки (string) не могут быть размером более 2 Гб (2147483647 байт).

Строка может быть определена четырьмя различными способами:

        одинарными кавычками
        двойными кавычками
        heredoc-синтаксисом
        nowdoc-синтаксисом (начиная с версии PHP 5.3.0)
Одинарные кавычки 
------------------
Простейший способ определить строку - это заключить ее в одинарные кавычки (символ ').

Чтобы использовать одинарную кавычку внутри строки, проэкранируйте ее обратной косой чертой (\). Если необходимо написать саму обратную косую черту, продублируйте ее (\\). Все остальные случаи применения обратной косой черты будут интерпретированы как обычные символы: это означает, что если вы попытаетесь использовать другие управляющие последовательности, такие как \r или \n, они будут выведены как есть вместо какого-либо особого поведения.

В отличие от синтаксиса двойных кавычек и heredoc, переменные и управляющие последовательности для специальных символов, заключенных в одинарные кавычки, не обрабатываются.

        <?php
        echo 'это простая строка';

        echo 'Также вы можете вставлять в строки
        символ новой строки вот так,
        это нормально';

        // Выводит: Однажды Арнольд сказал: "I'll be back"
        echo 'Однажды Арнольд сказал: "I\'ll be back"';

        // Выводит: Вы удалили C:\*.*?
        echo 'Вы удалили C:\\*.*?';

        // Выводит: Вы удалили C:\*.*?
        echo 'Вы удалили C:\*.*?';

        // Выводит: Это не будет развернуто: \n новая строка
        echo 'Это не будет развернуто: \n новая строка';

        // Выводит: Переменные $expand также $either не разворачиваются
        echo 'Переменные $expand также $either не разворачиваются';
        ?>
Двойные кавычки
---------------
Если строка заключена в двойные кавычки ("), PHP распознает большее количество управляющих последовательностей для специальных символов:

Управляющие последовательности
------------------------------
        Последовательность  Значение
        \n  новая строка (LF или 0x0A (10) в ASCII)
        \r  возврат каретки (CR или 0x0D (13) в ASCII)
        \t  горизонтальная табуляция (HT или 0x09 (9) в ASCII)
        \v  вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)
        \e  escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.4)
        \f  подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)
        \\  обратная косая черта
        \$  знак доллара
        \"  двойная кавычка
        \[0-7]{1,3} последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления
        \x[0-9A-Fa-f]{1,2}  последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления

самым важным свойством строк в двойных кавычках является обработка переменных.

Heredoc 
========
Третий способ определения строк - это использование heredoc-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, затем перевод строки. После этого идет сама строка, а потом этот же идентификатор, закрывающий вставку.

Строка должна начинаться с закрывающего идентификатора, т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается).

Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея. Это означает, что вам нет необходимости экранировать кавычки в heredoc, но вы по-прежнему можете использовать вышеперечисленные управляющие последовательности. Переменные обрабатываются, но с применением сложных переменных внутри heredoc нужно быть также внимательным, как и при работе со строками.

Пример  Пример определения heredoc-строки

        <?php
        $str = <<<EOD
        Пример строки,
        охватывающей несколько строчек,
        с использованием heredoc-синтаксиса.
        EOD;

        /* Более сложный пример с переменными. */
        class foo
        {
            var $foo;
            var $bar;

            function foo()
            {
                $this->foo = 'Foo';
                $this->bar = array('Bar1', 'Bar2', 'Bar3');
            }
        }

        $foo = new foo();
        $name = 'МоеИмя';

        echo <<<EOT
        Меня зовут "$name". Я печатаю $foo->foo.
        Теперь я вывожу {$foo->bar[1]}.
        Это должно вывести заглавную букву 'A': \x41
        EOT;
        ?>

Пример Пример применения heredoc в аргументах

        <?php
        var_dump(array(<<<EOD
        foobar!
        EOD
        ));
        ?>

Пример Использование heredoc для инциализации статических переменных

        <?php
        // Статические переменные
        function foo()
        {
            static $bar = <<<LABEL
        Здесь ничего нет...
        LABEL;
        }

        // Class properties/constants
        class foo
        {
            const BAR = <<<FOOBAR
        Пример использования константы
        FOOBAR;

            public $baz = <<<FOOBAR
        Пример использования поля
        FOOBAR;
        }
        ?>

Пример Использование двойных кавычек в heredoc

        <?php
        echo <<<"FOOBAR"
        Привет, мир!
        FOOBAR;
        ?>
Nowdoc 
======
Nowdoc - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок. Эта конструкция идеальна для внедрения PHP-кода или других больших блоков текста без необходимости его экранирования. 

Nowdoc указывается той же последовательностью <<<, что используется в heredoc, но последующий за ней идентификатор заключается в одинарные кавычки, например, <<<'EOT'. Все условия, действующие для heredoc идентификаторов также действительны и для nowdoc, особенно те, что относятся к закрывающему идентификатору.

Пример  Пример использования nowdoc

        <?php
        $str = <<<'EOD'
        Пример текста,
        занимающего несколько строк,
        с помощью синтаксиса nowdoc.
        EOD;

        /* Более сложный пример с переменными. */
        class foo
        {
            public $foo;
            public $bar;

            function foo()
            {
                $this->foo = 'Foo';
                $this->bar = array('Bar1', 'Bar2', 'Bar3');
            }
        }

        $foo = new foo();
        $name = 'МоеИмя';

        echo <<<'EOT'
        Меня зовут "$name". Я печатаю $foo->foo.
        Теперь я печатаю {$foo->bar[1]}.
        Это не должно вывести заглавную 'A': \x41
        EOT;
        ?>

В отличие от heredoc, nowdoc может быть использован в любом контексте со статическими данными. Типичный пример инициализации полей класса или констант:
Пример  Пример использования статичных данных

        <?php
        class foo {
            public $bar = <<<'EOT'
        bar
        EOT;
        }
        ?>

Обработка переменных 
====================
Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются.

Существует два типа синтаксиса: простой и сложный. Простой синтаксис более легок и удобен. Он дает возможность обработки переменной, значения массива (array) или свойства объекта (object) с минимумом усилий.

Сложный синтаксис может быть определен по фигурным скобкам, окружающим выражение.

Простой синтаксис
-----------------
Если интерпретатор встречает знак доллара ($), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки.

        <?php
        $juice = "apple";

        echo "He drank some $juice juice.".PHP_EOL;
        // не работает, 's' - это верный символ для имени переменной,
        // но наша переменная имеет имя $juice.
        echo "He drank some juice made of $juices.";
        ?>

Аналогично могут быть обработаны элемент массива (array) или свойство объекта (object). В индексах массива закрывающая квадратная скобка (]) обозначает конец определения индекса. Для свойств объекта применяются те же правила, что и для простых переменных.

Пример простого синтаксиса

        <?php
        $juices = array("apple", "orange", "koolaid1" => "purple");

        echo "He drank some $juices[0] juice.".PHP_EOL;
        echo "He drank some $juices[1] juice.".PHP_EOL;
        echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

        class people {
            public $john = "John Smith";
            public $jane = "Jane Smith";
            public $robert = "Robert Paulsen";
            
            public $smith = "Smith";
        }

        $people = new people();

        echo "$people->john drank some $juices[0] juice.".PHP_EOL;
        echo "$people->john then said hello to $people->jane.".PHP_EOL;
        echo "$people->john's wife greeted $people->robert.".PHP_EOL;
        echo "$people->robert greeted the two $people->smiths."; // Won't work
        ?>

Сложный (фигурный) синтаксис
----------------------------

Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. Просто запишите выражение так же, как и вне строки, а затем заключите его в { и }. Поскольку { не может быть экранирован, этот синтаксис будет распознаваться только когда $ следует непосредственно за {. Используйте {\$, чтобы напечатать {$. 

        <?php
        // Показываем все ошибки
        error_reporting(E_ALL);

        $great = 'здорово';

        // Не работает, выводит: Это { здорово}
        echo "Это { $great}";

        // Работает, выводит: Это здорово
        echo "Это {$great}";
        echo "Это ${great}";

        // Работает
        echo "Этот квадрат шириной {$square->width}00 сантиметров.";

        // Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок
        echo "Это работает: {$arr['key']}";

        // Работает
        echo "Это работает: {$arr[4][3]}";

        // Это неверно по той же причине, что и $foo[bar] вне
        // строки. Другими словами, это по-прежнему будет работать,
        // но поскольку PHP сначала ищет константу foo, это вызовет
        // ошибку уровня E_NOTICE (неопределенная константа).
        echo "Это неправильно: {$arr[foo][3]}";

        // Работает. При использовании многомерных массивов внутри
        // строк всегда используйте фигурные скобки
        echo "Это работает: {$arr['foo'][3]}";

        // Работает.
        echo "Это работает: " . $arr['foo'][3];

        echo "Это тоже работает: {$obj->values[3]->name}";

        echo "Это значение переменной по имени $name: {${$name}}";

        echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

        echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

        // Не работает, выводит: Это то, что возвращает getName(): {getName()}
        echo "Это то, что возвращает getName(): {getName()}";
        ?>

Доступ к символу в строке и его изменение 
-----------------------------------------
Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в квадратных скобках после строки, например, $str[42]. Думайте о строке для этой цели, как о массиве символов. Если нужно получить или заменить более 1 символа, можно использовать функции substr() и substr_replace().

К символу в строке также можно обращаться с помощью фигурных скобок, например, $str{42}.

Попытка записи в смещение за границами строки дополнит строку пробелами до этого смещения. Нецелые типы будет преобразованы в целые. Неверный тип смещения вызовет ошибку уровня E_NOTICE. Запись по отрицательному смещению вызовет ошибку уровня E_NOTICE, а при чтении вернет пустую строку. Используется только первый символ присваемой строки. Присвоение пустой строки присваивает нулевой байт (NULL).

Строки в PHP внутренне представляют из себя массивы байт. Как результат, доступ или изменение строки по смещению небезопасно с точки зрения многобайтной кодировки, и должно выполняться только со строками в однобайтных кодировках, таких как, например, ISO-8859-1.

Несколько примеров строк

        <?php
        // Получение первого символа строки
        $str = 'This is a test.';
        $first = $str[0];

        // Получение третьего символа строки
        $third = $str[2];

        // Получение последнего символа строки
        $str = 'This is still a test.';
        $last = $str[strlen($str)-1]; 

        // Изменение последнего символа строки
        $str = 'Look at the sea';
        $str[strlen($str)-1] = 'e';

        ?>

смещение в строке должно задаваться либо целым числом либо строкой, содержащей цифры, иначе будет выдаваться предупреждение. Ранее смещение, заданное строкой вида "foo", без предупреждений преобразовывалось в 0.


        <?php
        $str = 'abc';

        var_dump($str['1']);
        var_dump(isset($str['1']));

        var_dump($str['1.0']);
        var_dump(isset($str['1.0']));

        var_dump($str['x']);
        var_dump(isset($str['x']));

        var_dump($str['1x']);
        var_dump(isset($str['1x']));
        ?>


Полезные функции и операторы 
----------------------------
Строки могут быть объединены при помощи оператора '.' (точка). 

Преобразование в строку 
-----------------------
Значение может быть преобразовано в строку, с помощью приведения (string), либо функции strval(). В выражениях, где необходима строка, преобразование происходит автоматически. Это происходит, когда вы используете функции echo или print, либо когда значение переменной сравнивается со строкой. 

Значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в "" (пустую строку). Это позволяет преобразовывать значения в обе стороны - из булева типа в строковый и наоборот.

Целое (integer) или число с плавающей точкой (float) преобразуется в строку, представленную числом, состоящим из его цифр (включая показатель степени для чисел с плавающей точкой). Числа с плавающей точкой могут быть преобразованы с помощью экспоненциального представления (4.1E+6).

Символ десятичной точки определяется из настроек локали текущего скрипта (категория LC_NUMERIC). 

NULL всегда преобразуется в пустую строку.

способ вывода значений для отладки - использовать функции print_r() и var_dump().

Преобразование строк в числа 
----------------------------
Если строка не содержит какой-либо из символов '.', 'e', или 'E', и значение числа помещается в пределы целых чисел (определенных PHP_INT_MAX), строка будет распознана как целое число (integer). Во всех остальных случаях она считается числом с плавающей точкой (float).

Значение определяется по начальной части строки. Если строка начинается с верного числового значения, будет использовано это значение. Иначе значением будет 0 (ноль). Верное числовое значение - это одна или более цифр (могущих содержать десятичную точку), по желанию предваренных знаком, с последующим необязательным показателем степени. Показатель степени - это 'e' или 'E' с последующими одной или более цифрами.

        <?php
        $foo = 1 + "10.5";                // $foo это float (11.5)
        $foo = 1 + "-1.3e3";              // $foo это float (-1299)
        $foo = 1 + "bob-1.3e3";           // $foo это integer (1)
        $foo = 1 + "bob3";                // $foo это integer (1)
        $foo = 1 + "10 Small Pigs";       // $foo это integer (11)
        $foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
        $foo = "10.0 pigs " + 1;          // $foo это float (11)
        $foo = "10.0 pigs " + 1.0;        // $foo это float (11)
        ?>

public/index.php
----------------
        <?php

        require_once __DIR__.'/../bootstrap/app.php';

        ?>

        <!DOCTYPE html>
        <html class=''>
        <head>


bootstrap/app.php
-----------------

        <?php
        ob_start();
        session_start();

        //set timezone
        date_default_timezone_set('Europe/Kiev');

ob_start
=========
Эта функция включает буферизацию вывода. Если буферизация вывода активна, вывод скрипта не высылается (кроме заголовков), а сохраняется во внутреннем буфере.

Содержимое этого внутреннего буфера может быть скопировано в строковую переменную, используя ob_get_contents(). Для вывода содержимого внутреннего буфера следует использовать ob_end_flush(). В качестве альтернативы можно использовать ob_end_clean() для уничтожения содержимого буфера.

Некоторые web-сервера (например Apache) изменяют рабочую директорию скрипта, когда вызывается callback-функция. Вы можете вернуть ее назад, используя chdir(dirname($_SERVER['SCRIPT_FILENAME'])) в callback-функции.
Буферы вывода помещаются в стек, то есть допускается вызов ob_start() после вызова другой активной ob_start(). При этом необходимо вызывать ob_end_flush() соответствующее количество раз. Если активны несколько callback-функций, вывод последовательно фильтруется для каждой из них в порядке вложения.

Сессии session_start
====================

веб-сервер не поддерживает постоянного соединения с клиентом, и каждый запрос обрабатывается, как новый, безо всякой связи с предыдущими. То есть, нельзя ни отследить запросы от одного и того же посетителя, ни сохранить для него переменные между просмотрами отдельных страниц. 
Сессии - это механизм, позволяющий однозначно идентифицировать браузер и создающий для этого браузера файл на сервере, в котором хранятся переменные сеанса. 
Это корзина покупок в е-магазине, авторизация, защита интерактивных частей сайта от спама.

