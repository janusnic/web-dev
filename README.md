# web-dev

JAVASCRIPT
===========
Механизм использования PHP и Javascript на сайте
------------------------------------------------

Схема взаимодействие клиента и сервера:
---------------------------------------
                                                                   
 ---------------              --------------            ----------
|               |    HTML    |              |   HTTP   |          |
| Пользователь  |   <---->   |    Клиент    |  <---->  |  Сервер  |    
|               | Javascript |   (браузер)  |    PHP   |          |
 ---------------              --------------            ----------   

Из схемы видно, что браузер преобразовывает HTML-код и выдает пользователю для просмотра вашу страничку. Javascript может реагировать на нажатие ссылок или кнопок, менять вид страницы (не перегружая ее), вызывать другой URL в этом или другом окне (фрейме), перегружать эту страницу. Ваш сайт может быть построен только на HTML-файлах с включением (или без) Javascript.

При разработке динамического сайта (генерации содержания страниц по заданным параметрам, использовании базы данных) вам нужно использовать серверный скрипт.
PHP-скрипт может быть запущен на сервере несколькими способами:

- при перезагрузке страницы или активации URL следующего вида: http://ваш.сайт/скрипт.php;
- скрытым вызовом в html-коде или в Javascript;
- через cron (crontab – это программа, выполняющая задания по расписанию на сервере)

В первых двух способах есть возможность интеграции PHP и Javascript

Язык PHP предназначен для написания скриптов, которые выполняются на стороне сервера, а в браузер клиента отправляется не сам скрипт, а только результаты его работы.  Это означает, что пользователь, загрузивший страницу вашего сайта, никогда не увидит исходный код скрипта и может даже не догадываться, что страница создана динамически.

В свою очередь, на языке JavaScript создаются исключительно клиентские скрипты, которые исполняются в браузере клиента. Для сервера скрипты JavaScript – это обычные текстовые данные, ничем не отличающиеся от прочего содержимого страницы.

При выполнении PHP-скрипта вы можете обращаться к файловой системе сервера, базам данных и другим внешним объектам, на которые вам предоставили права администраторы. А вот JavaScript ограничен только встроенными объектами браузера и с их помощью вы не сможете читать или писать непосредственно на диск. Сделано это в первую очередь для защиты от злоумышленников.

Помимо прочего, протокол HTTP, по которому передаются все веб-страницы, не поддерживает постоянных соединений, т.е. браузер подключается к серверу, запрашивает страницу, получает данные и немедленно отключается. Это означает, что все скрипты PHP завершаются ещё ДО того, как начнутся выполняться скрипты JavaScript.

Переменные
==========

Чтобы хранить информацию, используются переменные.

Переменная состоит из имени и выделенной области памяти, которая ему соответствует.

Для объявления или, другими словами, создания переменной используется ключевое слово var:
```
var message;
```
После объявления, можно записать в переменную данные:
```
var message;
message = 'Hello'; // сохраним в переменной строку
```
Эти данные будут сохранены в соответствующей области памяти и в дальнейшем доступны при обращении по имени:
```
var message;
message = 'Hello!';

alert( message ); // выведет содержимое переменной
```
Для краткости можно совместить объявление переменной и запись данных:
```
var message = 'Hello!';
```
Можно даже объявить несколько переменных сразу:
```
var user = 'John', age = 25, message = 'Hello';
```

При изменении значения старое содержимое переменной удаляется.

Можно объявить две переменные и копировать данные из одной в другую:
```
var hello = 'Hello world!';

var message;

// скопировали значение
message = hello;

alert( hello ); // Hello world!
alert( message ); // Hello world!
```

Имена переменных
----------------
На имя переменной в JavaScript наложены всего два ограничения.

- Имя может состоять из: букв, цифр, символов $ и _
- Первый символ не должен быть цифрой.
Например:
```
var myName;
var test123;
```
Что особенно интересно — доллар '$' и знак подчеркивания '_' являются такими же обычными символами, как буквы:
```
var $ = 1; // объявили переменную с именем '$'
var _ = 2; // переменная с именем '_'

alert( $ + _ ); // 3
```
А такие переменные были бы неправильными:
```
var 1a; // начало не может быть цифрой

var my-name; // дефис '-' не является разрешенным символом
```
Регистр букв имеет значение
---------------------------
Переменные apple и AppLE — две разные переменные.

Русские буквы допустимы, но не рекомендуются
---------------------------------------------
В названии переменных можно использовать и русские буквы, например:
```
var имя = "Вася";
alert( имя ); // "Вася"
```
Технически, ошибки здесь нет, но на практике сложилась традиция использовать в именах только английские буквы.

Зарезервированные имена
------------------------
Существует список зарезервированных слов, которые нельзя использовать для переменных, так как они используются самим языком, например: var, class, return, export и др.

Например, такой пример выдаст синтаксическую ошибку:
```
var return = 5; // ошибка
alert(return);
```
Важность директивы var
----------------------
В старом стандарте JavaScript разрешалось создавать переменную и без var, просто присвоив ей значение:
```
num = 5; // переменная num будет создана, если ее не было
```
В режиме "use strict" так делать уже нельзя.

Следующий код выдаст ошибку:
```
"use strict";

num = 5; // error: num is not defined
```
Обратим внимание, директиву use strict нужно ставить до кода, иначе она не сработает:

```
var something;

"use strict"; // слишком поздно

num = 5; // ошибки не будет, так как строгий режим не активирован
```
Ошибка в IE8- без var
---------------------
Если же вы собираетесь поддерживать IE8-, то у меня для вас ещё одна причина всегда использовать var.
Следущий документ в IE8- ничего не выведет, будет ошибка:

```
<div id="test"></div>
<script>
  test = 5; // здесь будет ошибка!
  alert( test ); // не сработает
</script>
```
Это потому, что переменная test не объявлена через var и совпадает с id элемента div. 

Вывод простой — всегда объявляем переменные через var, и сюрпризов не будет. Даже в старых IE.

Константы
----------
Константа — это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:
```
var COLOR_RED = "#F00";
var COLOR_GREEN = "#0F0";
var COLOR_BLUE = "#00F";
var COLOR_ORANGE = "#FF7F00";

var color = COLOR_ORANGE;
alert( color ); // #FF7F00
```
Технически, константа является обычной переменной, то есть её можно изменить. Но мы договариваемся этого не делать.

Зачем нужны константы? Почему бы просто не писать var color = "#FF7F00"?

Во-первых, константа COLOR_ORANGE — это понятное имя. По присвоению var color="#FF7F00" непонятно, что цвет — оранжевый. Иными словами, константа COLOR_ORANGE является «понятным псевдонимом» для значения #FF7F00.
Во-вторых, опечатка в строке, особенно такой сложной как #FF7F00, может быть не замечена, а в имени константы её допустить куда сложнее.
Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.

Правильный выбор имени переменной
----------------------------------
Правильный выбор имени переменной — одна из самых важных и сложных вещей в программировании, которая отличает начинающего от гуру.

Дело в том, что большинство времени мы тратим не на изначальное написание кода, а на его развитие.

Возможно, эти слова не очевидны, если вы пока что ничего большого не писали или пишете код «только для чтения» (написал 5 строк, отдал заказчику и забыл). Но чем более серьёзные проекты вы будете делать, тем более актуальны они будут для вас.

Что такое это «развитие»? Это когда я вчера написал код, а сегодня (или спустя неделю) прихожу и хочу его поменять. Например, вывести сообщение не так, а эдак… Обработать товары по-другому, добавить функционал.. А где у меня там сообщение хранится? А где товар?…

Гораздо проще найти нужные данные, если они правильно помечены, то есть когда переменная названа правильно.

Правила именования
------------------
1. Правило 1.
Никакого транслита. Только английский.

Неприемлемы:
```
var moiTovari;
var cena;
var ssilka;
```
Подойдут:
```
var myGoods;
var price;
var link;
```
Чем плох транслит?
------------------
Во-первых, среди разработчиков всего мира принято использовать английский язык для имён переменных. И если ваш код потом попадёт к кому-то другому, например вы будете в команде больше чем из одного человека, то велик шанс, что транслит ему не понравится.

Во-вторых, русский транслит хуже читается и длиннее, чем названия на английском.

В-третьих, в проектах вы наверняка будете применять библиотеки, написанные другими людьми. Многое уже готово, в распоряжении современного разработчика есть масса инструментов, все они используют названия переменных и функций на английском языке, и вы, конечно, будете их использовать. А от кода, где транслит перемешан с английским — волосы могут встать дыбом, и не только на голове.

Если вы вдруг не знаете английский — самое время выучить.

2. Правило 2.

Использовать короткие имена только для переменных «местного значения».

Называть переменные именами, не несущими смысловой нагрузки, например a, e, p, mg — можно только в том случае, если они используются в небольшом фрагменте кода и их применение очевидно.

Вообще же, название переменной должно быть понятным. Иногда для этого нужно использовать несколько слов.

3. Правило 3.
Переменные из нескольких слов пишутся вместеВотТак.

Например:
```
var borderLeftWidth;
```
Этот способ записи называется «верблюжьей нотацией» или, по-английски, «camelCase».

Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания '_':
```
var border_left_width;
```
Преимущественно в JavaScript используется вариант borderLeftWidth, в частности во встроенных языковых и браузерных функциях. Поэтому целесообразно остановиться на нём.

Ещё одна причина выбрать «верблюжью нотацию» — запись в ней немного короче, чем c подчеркиванием, т.к. не нужно вставлять '_'.

4. Правило последнее, главное.
Имя переменной должно максимально чётко соответствовать хранимым в ней данным.

Придумывание таких имен — одновременно коротких и точных, при которых всегда понятно, что где лежит, приходит с опытом, но только если сознательно стремиться к этому.

Основные операторы
==================
Для работы с переменными, со значениями, JavaScript поддерживает все стандартные операторы, большинство которых есть и в других языках программирования.

Несколько операторов мы знаем со школы — это обычные сложение +, умножение *, вычитание и так далее.


Термины: «унарный», «бинарный», «операнд»
------------------------------------------
У операторов есть своя терминология, которая используется во всех языках программирования.

Операнд — то, к чему применяется оператор. Например: 5 * 2 — оператор умножения с левым и правым операндами. Другое название: «аргумент оператора».
Унарным называется оператор, который применяется к одному выражению. Например, оператор унарный минус "-" меняет знак числа на противоположный:

```

var x = 1;

x = -x;
alert( x ); // -1, применили унарный минус
```
Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
```
var x = 1, y = 3;
alert( y - x ); // 2, бинарный минус
```
Сложение строк, бинарный +
---------------------------
Обычно при помощи плюса '+' складывают числа.

Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
```
var a = "моя" + "строка";
alert( a ); // моястрока
```
Иначе говорят, что «плюс производит конкатенацию (сложение) строк».

Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!

Причем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:
```
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
Это приведение к строке — особенность исключительно бинарного оператора "+".

Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

Например:
```
alert( 2 - '1' ); // 1
alert( 6 / '2' ); // 3
```
Преобразование к числу, унарный плюс +
---------------------------------------
Унарный, то есть применённый к одному значению, плюс ничего не делает с числами:
```
alert( +1 ); // 1
alert( +(1 - 2) ); // -1
```
Как видно, плюс ничего не изменил в выражениях. Результат — такой же, как и без него.

Тем не менее, он широко применяется, так как его «побочный эффект» — преобразование значения в число.

Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк.

А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:
```
var apples = "2";
var oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс складывает строки
```
Поэтому используем унарный плюс, чтобы преобразовать к числу:
```
var apples = "2";
var oranges = "3";

alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа
```
С точки зрения математики такое изобилие плюсов может показаться странным. С точки зрения программирования — никаких разночтений: сначала выполнятся унарные плюсы, приведут строки к числам, а затем — бинарный '+' их сложит.

Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.

Приоритет
----------
В том случае, если в выражении есть несколько операторов — порядок их выполнения определяется приоритетом.

Из школы мы знаем, что умножение в выражении 2 * 2 + 1 выполнится раньше сложения, т.к. его приоритет выше, а скобки явно задают порядок выполнения. Но в JavaScript — гораздо больше операторов, поэтому существует целая таблица приоритетов.

Она содержит как уже пройденные операторы, так и те, которые мы еще не проходили. В ней каждому оператору задан числовой приоритет. Тот, у кого число больше — выполнится раньше. Если приоритет одинаковый, то порядок выполнения — слева направо.

```
15  унарный плюс    +
15  унарный минус   -
14  умножение   *
14  деление /
13  сложение    +
13  вычитание   -
…   …   …
3   присвоение  =
…   …   …
```
Так как «унарный плюс» имеет приоритет 15, выше, чем 13 у обычного «сложения», то в выражении +apples + +oranges сначала сработали плюсы у apples и oranges, а затем уже обычное сложение.

Присваивание
------------
Обратим внимание, в таблице приоритетов также есть оператор присваивания =.

У него — один из самых низких приоритетов: 3.

Именно поэтому, когда переменную чему-либо присваивают, например, x = 2 * 2 + 1 сначала выполнится арифметика, а уже затем — произойдёт присвоение =.
```
var x = 2 * 2 + 1;

alert( x ); // 5
```
Возможно присваивание по цепочке:
---------------------------------
```
var a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```
Такое присваивание работает справа-налево, то есть сначала вычислятся самое правое выражение 2+2, присвоится в c, затем выполнится b = c и, наконец, a = b.

Оператор "=" возвращает значение
--------------------------------
Все операторы возвращают значение. Вызов x = выражение не является исключением.
Он записывает выражение в x, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:

```
var a = 1;
var b = 2;

var c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```
В примере выше результатом (a = b + 1) является значение, которое записывается в a (т.е. 3). Оно используется для вычисления c.

Знать, как это работает — стоит обязательно, а вот писать самому — только если вы уверены, что это сделает код более читаемым и понятным.

Взятие остатка %
------------------
Оператор взятия остатка % интересен тем, что, несмотря на обозначение, никакого отношения к процентам не имеет.

Его результат a % b — это остаток от деления a на b.

Например:
```
alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
alert( 6 % 3 ); // 0, остаток от деления 6 на 3
```
Инкремент/декремент: ++, --
----------------------------
Одной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу.

Для этого существуют даже специальные операторы:

Инкремент ++ увеличивает на 1:
-------------------------------
```
var i = 2;
i++;      // более короткая запись для i = i + 1.
alert(i); // 3
```
Декремент -- уменьшает на 1:
----------------------------
```
var i = 2;
i--;      // более короткая запись для i = i - 1.
alert(i); // 1
```

Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.
Вызывать эти операторы можно не только после, но и перед переменной: i++ (называется «постфиксная форма») или ++i («префиксная форма»).

Обе эти формы записи делают одно и то же: увеличивают на 1.

Тем не менее, между ними существует разница. Она видна только в том случае, когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении.

Например:
```
var i = 1;
var a = ++i; // (*)

alert(a); // 2
```
В строке (*) вызов ++i увеличит переменную, а затем вернёт ее значение в a. Так что в a попадёт значение i после увеличения.

Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.

В примере ниже в a попадёт старое значение i, равное 1:
```
var i = 1;
var a = i++; // (*)

alert(a); // 1
```
Если результат оператора не используется, а нужно только увеличить/уменьшить переменную — без разницы, какую форму использовать:
```
var i = 0;
i++;
++i;
alert( i ); // 2
```
Если хочется тут же использовать результат, то нужна префиксная форма:
```
var i = 0;
alert( ++i ); // 1
```
Если нужно увеличить, но нужно значение переменной до увеличения — постфиксная форма:
```
var i = 0;
alert( i++ ); // 0
```
Инкремент/декремент можно использовать в любых выражениях
----------------------------------------------------------
При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции:
```
var i = 1;
alert( 2 * ++i ); // 4
var i = 1;
alert( 2 * i++ ); // 2, выполнился раньше но значение вернул старое
```
При этом, нужно с осторожностью использовать такую запись, потому что в более длинной строке при быстром «вертикальном» чтении кода легко пропустить такой i++, и будет неочевидно, что переменая увеличивается.

Три строки, по одному действию в каждой — длиннее, зато нагляднее:
```
var i = 1;
alert( 2 * i );
i++;
```
Побитовые операторы
-------------------
Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:
```
AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
```
Сокращённая арифметика с присваиванием
--------------------------------------
Часто нужно применить оператор к переменной и сохранить результат в ней же, например:
```
var n = 2;
n = n + 5;
n = n * 2;
````
Эту запись можно укоротить при помощи совмещённых операторов, вот так:
```
var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)
n *= 2; // теперь n=14 (работает как n = n * 2)

alert( n ); // 14
```
Так можно сделать для операторов +,-,*,/ и бинарных <<,>>,>>>,&,|,^.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:
```
var n = 2;
n *= 3 + 5;

alert( n ); // 16  (n = 2 * 8)
```
Оператор запятая
-----------------
Один из самых необычных операторов — запятая ','.

Его можно вызвать явным образом, например:

```
var a = (5, 6);

alert( a );
```
Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них — вычисляется и отбрасывается, за исключением последнего, которое возвращается.

Запятая — единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6.

Зачем же нужен такой странный оператор, который отбрасывает значения всех перечисленных выражений, кроме последнего?

Обычно он используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:
```
// три операции в одной строке
for (a = 1, b = 3, c = a*b; a < 10; a++) {
 ...
}
```
Такие трюки используются во многих JavaScript-фреймворках для укорачивания кода.

Взаимодействие с пользователем: alert, prompt, confirm
======================================================

alert
------
```
alert(сообщение)
```
alert выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмёт «ОК».
```
alert( "Привет" );
```
Окно сообщения, которое выводится, является модальным окном. Слово «модальное» означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не  нажмёт на «OK».

prompt
------
Функция prompt принимает два аргумента:
```
result = prompt(title, default);
```
Она выводит модальное окно с заголовком title, полем для ввода текста, заполненным строкой по умолчанию default и кнопками OK/CANCEL.

Пользователь должен либо что-то ввести и нажать OK, либо отменить ввод кликом на CANCEL или нажатием Esc на клавиатуре.

Вызов prompt возвращает то, что ввёл посетитель — строку или специальное значение null, если ввод отменён.

Safari 5.1+ не возвращает null

Единственный браузер, который не возвращает null при отмене ввода — это Safari. При отсутствии ввода он возвращает пустую строку. Предположительно, это ошибка в браузере.
Если нам важен этот браузер, то пустую строку нужно обрабатывать точно так же, как и null, т.е. считать отменой ввода.

Как и в случае с alert, окно prompt модальное.
```
var years = prompt('Сколько вам лет?', 100);

alert('Вам ' + years + ' лет!')
```
Всегда указывайте default
Второй параметр может отсутствовать. Однако при этом IE вставит в диалог значение по умолчанию "undefined".
Запустите этот код в IE, чтобы понять о чём речь:
```
var test = prompt("Тест");
```
Поэтому рекомендуется всегда указывать второй аргумент:
```
var test = prompt("Тест", ''); // <-- так лучше
```
confirm
--------
```
result = confirm(question);
```
confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc).

```
var isAdmin = confirm("Вы - администратор?");

alert( isAdmin );
```
Особенности встроенных функций
--------------------------------
Конкретное место, где выводится модальное окно с вопросом — обычно это центр браузера, и внешний вид окна выбирает браузер. Разработчик не может на это влиять.


Шесть типов данных, typeof
==========================
В JavaScript существует несколько основных типов данных.

Число «number»
--------------
```
var n = 123;
n = 12.345;
```
Единый тип число используется как для целых, так и для дробных чисел.

Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений).

Например, бесконечность Infinity получается при делении на ноль:
```
alert( 1 / 0 ); // Infinity
```
Ошибка вычислений NaN будет результатом некорректной математической операции, например:
```
alert( "нечисло" * 2 ); // NaN, ошибка
```
Эти значения формально принадлежат типу «число», хотя, конечно, числами в их обычном понимании не являются.

Строка «string»
----------------
```
var str = "Мама мыла раму";
str = 'Одинарные кавычки тоже подойдут';
```
В JavaScript одинарные и двойные кавычки равноправны. Можно использовать или те или другие.

Тип символ не существует, есть только строка.

Булевый (логический) тип «boolean»
-----------------------------------
У него всего два значения: true (истина) и false (ложь).

Как правило, такой тип используется для хранения значения типа да/нет, например:
```
var checked = true; // поле формы помечено галочкой
checked = false;    // поле формы не содержит галочки
```

Специальное значение «null»
---------------------------
Значение null не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения null:
```
var age = null;
```
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

Специальное значение «undefined»
--------------------------------
Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено».

Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined:
```
var x;
alert( x ); // выведет "undefined"
```
Можно присвоить undefined и в явном виде, хотя это делается редко:
```
var x = 123;
x = undefined;

alert( x ); // "undefined"
```
В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.

Объекты «object»
----------------
Первые 5 типов называют «примитивными».

Особняком стоит шестой тип: «объекты».

Он используется для коллекций данных и для объявления более сложных сущностей.

Объявляются объекты при помощи фигурных скобок {...}, например:
```
var user = { name: "Вася" };
```

Оператор typeof
----------------
Оператор typeof возвращает тип аргумента.

У него есть два синтаксиса: со скобками и без:

1. Синтаксис оператора: typeof x.
2. Синтаксис функции: typeof(x).
Работают они одинаково, но первый синтаксис короче.

Результатом typeof является строка, содержащая тип:

```
typeof undefined // "undefined"

typeof 0 // "number"

typeof true // "boolean"

typeof "foo" // "string"

typeof {} // "object"

typeof null // "object"  (1)

typeof function(){} // "function"  (2)
```

Результат typeof null == "object" — это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле null — это не объект, а отдельный тип данных.

Условные операторы: if, '?'
---------------------------
Иногда, в зависимости от условия, нужно выполнить различные действия. Для этого используется оператор if.
```

var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');

if (year != 2011) alert( 'А вот и неправильно!' );
```
Оператор if
-----------
Оператор if («если») получает условие, в примере выше это year != 2011. Он вычисляет его, и если результат — true, то выполняет команду.

Если нужно выполнить более одной команды — они оформляются блоком кода в фигурных скобках:
```
if (year != 2011) {
  alert( 'А вот..' );
  alert( '..и неправильно!' );
}
```
Рекомендуется использовать фигурные скобки всегда, даже когда команда одна.

Это улучшает читаемость кода.

Преобразование к логическому типу
-----------------------------------
Оператор if (...) вычисляет и преобразует выражение в скобках к логическому типу.

Число 0, пустая строка "", null и undefined, а также NaN являются false,
------------------------------------------------------------------------
Остальные значения — true.
--------------------------
Например, такое условие никогда не выполнится:
```
if (0) { // 0 преобразуется к false
  ...
}
```
…А такое — выполнится всегда:
```
if (1) { // 1 преобразуется к true
  ...
}
```
Можно и просто передать уже готовое логическое значение, к примеру, заранее вычисленное в переменной:
```
var cond = (year != 2011); // true/false

if (cond) {
  ...
}
```
Неверное условие, else
----------------------
Необязательный блок else («иначе») выполняется, если условие неверно:
```
var year = prompt('Введите год появления стандарта ECMA-262 5.1', '');

if (year == 2011) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2011
}
```
Несколько условий, else if
--------------------------
Бывает нужно проверить несколько вариантов условия. Для этого используется блок else if .... Например:
```
var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');

if (year < 2011) {
  alert( 'Это слишком рано..' );
} else if (year > 2011) {
  alert( 'Это поздновато..' );
} else {
  alert( 'Да, точно в этом году!' );
}
```
В примере выше JavaScript сначала проверит первое условие, если оно ложно — перейдет ко второму — и так далее, до последнего else.

Оператор вопросительный знак '?'
--------------------------------
Иногда нужно в зависимости от условия присвоить переменную. Например:

```
var access;
var age = prompt('Сколько вам лет?', '');

if (age > 14) {
  access = true;
} else {
  access = false;
}

alert(access);
```
Оператор вопросительный знак '?' позволяет делать это короче и проще.
----------------------------------------------------------------------
Он состоит из трех частей:
```
условие ? значение1 : значение2
```
Проверяется условие, затем если оно верно — возвращается значение1, если неверно — значение2, например:
```
access = (age > 14) ? true : false;
```
Оператор '?' выполняется позже большинства других, в частности — позже сравнений, поэтому скобки можно не ставить:
```
access = age > 14 ? true : false;
```
…Но когда скобки есть — код лучше читается. Так что рекомендуется их писать.

В данном случае можно было бы обойтись и без оператора '?', т.к. сравнение само по себе уже возвращает true/false:
```
access = age > 14;
```
«Тернарный оператор»
--------------------
Вопросительный знак — единственный оператор, у которого есть аж три аргумента, в то время как у обычных операторов их один-два. Поэтому его называют «тернарный оператор».
Несколько операторов '?'
------------------------

Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких.

Например:
```
var age = prompt('возраст?', 18);

var message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );
```
Вопросительный знак проверяет сначала age < 3, если верно — возвращает 'Здравствуй, малыш!', если нет — идет за двоеточие и проверяет age < 18. Если это верно — возвращает 'Привет!', иначе проверка age < 100 и 'Здравствуйте!'… И наконец, если ничего из этого не верно, то 'Какой необычный возраст!'.

То же самое через if..else:
---------------------------
```
if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}
```
Нетрадиционное использование '?'
--------------------------------
Иногда оператор вопросительный знак '?' используют как замену if:
```
var company = prompt('Какая компания создала JavaScript?', '');

(company == 'Netscape') ?
   alert('Да, верно') : alert('Неправильно');
```
Работает это так: в зависимости от условия, будет выполнена либо первая, либо вторая часть после '?'.

Результат выполнения не присваивается в переменную, так что пропадёт (впрочем, alert ничего не возвращает).

Рекомендуется не использовать вопросительный знак таким образом.

Несмотря на то, что с виду такая запись короче if, она является существенно менее читаемой.

Вот, для сравнения, то же самое с if:
```

var company = prompt('Какая компания создала JavaScript?', '');

if (company == 'Netscape') {
  alert('Да, верно');
} else {
  alert('Неправильно');
}
```
При чтении кода глаз идёт вертикально и конструкции, занимающие несколько строк, с понятной вложенностью, воспринимаются гораздо легче. Возможно, вы и сами почувствуете, пробежавшись глазами, что синтаксис с if более прост и очевиден чем с оператором '?'.

Смысл оператора '?' — вернуть то или иное значение, в зависимости от условия.

Циклы while, for
==================
При написании скриптов зачастую встает задача сделать однотипное действие много раз.

Например, вывести товары из списка один за другим. Или просто перебрать все числа от 1 до 10 и для каждого выполнить одинаковый код.

Для многократного повторения одного участка кода – предусмотрены циклы.

Цикл while
-----------
Цикл while имеет вид:
```
while (условие) {
  // код, тело цикла
}
```
Пока условие верно — выполняется код из тела цикла.

Например, цикл ниже выводит i пока i < 3:
```
var i = 0;
while (i < 3) {
  alert( i );
  i++;
}
```
Повторение цикла по-научному называется «итерация». Цикл в примере выше совершает три итерации.

Если бы i++ в коде выше не было, то цикл выполнялся бы (в теории) вечно. На практике, браузер выведет сообщение о «зависшем» скрипте и посетитель его остановит.

Бесконечный цикл можно сделать и проще:
```
while (true) {
  // ...
}
```
Условие в скобках интерпретируется как логическое значение, поэтому вместо while (i!=0) обычно пишут while (i):
```
var i = 3;
while (i) { // при i, равном 0, значение в скобках будет false и цикл остановится
  alert( i );
  i--;
}
```
Цикл do..while
-----------------
Проверку условия можно поставить под телом цикла, используя специальный синтаксис do..while:
```
do {
  // тело цикла
} while (условие);
```
Цикл, описанный, таким образом, сначала выполняет тело, а затем проверяет условие.

Например:
```
var i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```
Синтаксис do..while редко используется, т.к. обычный while нагляднее — в нём не приходится искать глазами условие и ломать голову, почему оно проверяется именно в конце.

Цикл for
----------
Чаще всего применяется цикл for. Выглядит он так:
```
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```
Пример цикла, который выполняет alert(i) для i от 0 до 2 включительно (до 3):
```
var i;

for (i = 0; i < 3; i++) {
  alert( i );
}
```
Здесь:

- Начало: i=0.
- Условие: i<3.
- Шаг: i++.
- Тело: alert(i), т.е. код внутри фигурных скобок (они не обязательны, если только одна операция)

Цикл выполняется так:
----------------------
- Начало: i=0 выполняется один-единственный раз, при заходе в цикл.
- Условие: i<3 проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.
- Тело: alert(i).
- Шаг: i++ выполняется после тела на каждой итерации, но перед проверкой условия.
- Идти на шаг 2.
Иными словами, поток выполнения: начало → (если условие → тело → шаг) → (если условие → тело → шаг) → … и так далее, пока верно условие.

В цикле также можно определить переменную:
```
for (var i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
```
Эта переменная будет видна и за границами цикла, в частности, после окончания цикла i станет равно 3.

Пропуск частей for
------------------
Любая часть for может быть пропущена.

Например, можно убрать начало. Цикл в примере ниже полностью идентичен приведённому выше:
```
var i = 0;

for (; i < 3; i++) {
  alert( i ); // 0, 1, 2
}
```
Можно убрать и шаг:
```
var i = 0;

for (; i < 3;) {
  alert( i );
  // цикл превратился в аналог while (i<3)
}
```
А можно и вообще убрать всё, получив бесконечный цикл:
```
for (;;) {
  // будет выполняться вечно
}
```
При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.

for..in
--------
Существует также специальная конструкция for..in для перебора свойств объекта.

Прерывание цикла: break
-----------------------
Выйти из цикла можно не только при проверке условия но и, вообще, в любой момент. Эту возможность обеспечивает директива break.

Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем — выдаёт:

```
var sum = 0;

while (true) {

  var value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );
```
Директива break в строке (*), если посетитель ничего не ввёл, полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на alert.

Следующая итерация: continue
-----------------------------
Директива continue прекращает выполнение текущей итерации цикла.

Она прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось.

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

Например, цикл ниже использует continue, чтобы не выводить чётные значения:

```

for (var i = 0; i < 10; i++) {

  if (i % 2 == 0) continue;

  alert(i);
}
```
Для чётных i срабатывает continue, выполнение тела прекращается и управление передаётся на следующий проход for.

Директива continue позволяет обойтись без скобок
-------------------------------------------------
Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
```
for (var i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```
С технической точки зрения он полностью идентичен. Действительно, вместо continue можно просто завернуть действия в блок if. Однако, мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри if более длинный, то это ухудшает читаемость, в отличие от варианта с continue.

Нельзя использовать break/continue справа от оператора '?'
----------------------------------------------------------
Обычно мы можем заменить if на оператор вопросительный знак '?'.
То есть, запись:
```
if (условие) {
  a();
} else {
  b();
}
```
…Аналогична записи:
```
условие ? a() : b();
```
В обоих случаях в зависимости от условия выполняется либо a() либо b().

Но разница состоит в том, что оператор вопросительный знак '?', использованный во второй записи, возвращает значение.

Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'.

К таким относятся большинство конструкций и, в частности, break/continue.

Поэтому такой код приведёт к ошибке:
```
     (i > 5) ? alert(i) : continue;
```

Метки для break/continue
-------------------------
Бывает нужно выйти одновременно из нескольких уровней цикла.

Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:
```

outer: for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {

    var input = prompt('Значение в координатах '+i+','+j, '');

    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)

  }
}
alert('Готово!');

В коде выше для этого использована метка.
```
Метка имеет вид "имя:", имя должно быть уникальным. Она ставится перед циклом, вот так:
```
outer: for (var i = 0; i < 3; i++) { ... }
```
Можно также выносить её на отдельную строку:
```
outer:
for (var i = 0; i < 3; i++) { ... }
```
Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.

В примере выше это означает, что будет разорван самый внешний цикл и управление перейдёт на alert.

Директива continue также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.

JavaScript поддерживает три вида циклов:
----------------------------------------
1. while — проверка условия перед каждым выполнением.
2. do..while — проверка условия после каждого выполнения.
3. for — проверка условия перед каждым выполнением, а также дополнительные настройки.

- Чтобы организовать бесконечный цикл, используют конструкцию while(true). При этом он, как и любой другой цикл, может быть прерван директивой break.

- Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует — используют директиву continue.

Обе этих директивы поддерживают «метки», которые ставятся перед циклом. Метки — единственный способ для break/continue повлиять на выполнение внешнего цикла.

Функции
========
Зачастую нам надо повторять одно и то же действие во многих частях программы.

Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.

Примеры встроенных функций вы уже видели — это alert(message), prompt(message, default) и confirm(question). Но можно создавать и свои.

Объявление
-----------
```

function showMessage() {
  alert( 'Привет всем присутствующим!' );
}
```
Вначале идет ключевое слово function, после него имя функции, затем список параметров в скобках (в примере выше он пустой) и тело функции — код, который выполняется при её вызове.

Объявленная функция доступна по имени, например:
```
function showMessage() {
  alert( 'Привет всем присутствующим!' );
}

showMessage();
showMessage();
```
Этот код выведет сообщение два раза. Уже здесь видна главная цель создания функций: избавление от дублирования кода.

Если понадобится поменять сообщение или способ его вывода — достаточно изменить его в одном месте: в функции, которая его выводит.

Локальные переменные
--------------------
Функция может содержать локальные переменные, объявленные через var. Такие переменные видны только внутри функции:
```
function showMessage() {
  var message = 'Привет, я - Вася!'; // локальная переменная

  alert( message );
}

showMessage(); // 'Привет, я - Вася!'

alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри
```
Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.

При объявлении переменной в таких блоках, она всё равно будет видна во всей функции.

Например:

```   
function count() {
  // переменные i,j не будут уничтожены по окончании цикла
  for (var i = 0; i < 3; i++) {
    var j = i * 2;
  }

  alert( i ); // i=3, последнее значение i, при нём цикл перестал работать
  alert( j ); // j=4, последнее значение j, которое вычислил цикл
}
```
Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.

Объявления переменных в примере выше можно передвинуть вверх, это ни на что не повлияет:

```
function count() {
  var i, j; // передвинули объявления var в начало
  for (i = 0; i < 3; i++) {
    j = i * 2;
  }

  alert( i ); // i=3
  alert( j ); // j=4
}
```
Внешние переменные
-------------------
Функция может обратиться ко внешней переменной, например:
```
var userName = 'Вася';

function showMessage() {
  var message = 'Привет, я ' + userName;
  alert(message);
}

showMessage(); // Привет, я Вася
```
Доступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции:

```
var userName = 'Вася';

function showMessage() {
  userName = 'Петя'; // (1) присвоение во внешнюю переменную

  var message = 'Привет, я ' + userName;
  alert( message );
}

showMessage();

alert( userName ); // Петя, значение внешней переменной изменено функцией
```
Конечно, если бы внутри функции, в строке (1), была бы объявлена своя локальная переменная var userName, то все обращения использовали бы её, и внешняя переменная осталась бы неизменной.

Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными».

В примере выше переменная userName — глобальная.

Делайте глобальными только те переменные, которые действительно имеют общее значение для вашего проекта, а нужные для решения конкретной задачи — пусть будут локальными в соответствующей функции.

Внимание: неявное объявление глобальных переменных!
----------------------------------------------------
В старом стандарте JavaScript существовала возможность неявного объявления переменных присвоением значения.

Например:
```
function showMessage() {
  message = 'Привет'; // без var!
}

showMessage();

alert( message ); // Привет
```
В коде выше переменная message нигде не объявлена, а сразу присваивается. Скорее всего, программист просто забыл поставить var.

При use strict такой код привёл бы к ошибке, но без него переменная будет создана автоматически, причём в примере выше она создаётся не в функции, а на уровне всего скрипта.

Избегайте этого.

Здесь опасность даже не в автоматическом создании переменной, а в том, что глобальные переменные должны использоваться тогда, когда действительно нужны «общескриптовые» параметры.

Забыли var в одном месте, потом в другом — в результате одна функция неожиданно поменяла глобальную переменную, которую использует другая. И поди разберись, кто и когда её поменял, не самая приятная ошибка для отладки.

Параметры
----------
При вызове функции ей можно передать данные, которые та использует по своему усмотрению.

Например, этот код выводит два сообщения:
```
function showMessage(from, text) { // параметры from, text

  from = "** " + from + " **"; // здесь может быть сложный код оформления

  alert(from + ': ' + text);
}

showMessage('Маша', 'Привет!');
showMessage('Маша', 'Как дела?');
```
Параметры копируются в локальные переменные функции.
----------------------------------------------------
Например, в коде ниже есть внешняя переменная from, значение которой при запуске функции копируется в параметр функции с тем же именем. Далее функция работает уже с параметром:

```
function showMessage(from, text) {
  from = '**' + from + '**'; // меняем локальную переменную from
  alert( from + ': ' + text );
}

var from = "Маша";

showMessage(from, "Привет");

alert( from ); // старое значение from без изменений, в функции была изменена копия
```
Аргументы по умолчанию
-----------------------
Функцию можно вызвать с любым количеством аргументов.

Если параметр не передан при вызове — он считается равным undefined.

Например, функцию показа сообщения showMessage(from, text) можно вызвать с одним аргументом:
```
showMessage("Маша");
```
При этом можно проверить, и если параметр не передан — присвоить ему значение «по умолчанию»:
```
function showMessage(from, text) {
  if (text === undefined) {
    text = 'текст не передан';
  }

  alert( from + ": " + text );
}

showMessage("Маша", "Привет!"); // Маша: Привет!
showMessage("Маша"); // Маша: текст не передан
```
При объявлении функции необязательные аргументы, как правило, располагают в конце списка.

Для указания значения «по умолчанию», то есть, такого, которое используется, если аргумент не указан, используется два способа:

Можно проверить, равен ли аргумент undefined, и если да — то записать в него значение по умолчанию. Этот способ продемонстрирован в примере выше.

Использовать оператор ||:
-------------------------
```
function showMessage(from, text) {
  text = text || 'текст не передан';

  ...
}
```
Второй способ считает, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false.

Если аргументов передано больше, чем надо, например showMessage("Маша", "привет", 1, 2, 3), то ошибки не будет. Но, чтобы получить такие «лишние» аргументы, нужно будет прочитать их из специального объекта arguments, который мы рассмотрим в главе Псевдомассив аргументов “arguments”.

Возврат значения
-----------------
Функция может возвратить результат, который будет передан в вызвавший её код.

Например, создадим функцию calcD, которая будет возвращать дискриминант квадратного уравнения по формуле b2 - 4ac:
```
function calcD(a, b, c) {
   return b*b - 4*a*c;
}

var test = calcD(-4, 2, 1);
alert(test); // 20
```
Для возврата значения используется директива return.
----------------------------------------------------
Она может находиться в любом месте функции. Как только до неё доходит управление — функция завершается и значение передается обратно.

Вызовов return может быть и несколько, например:
```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Родители разрешили?');
  }
}

var age = prompt('Ваш возраст?');

if (checkAge(age)) {
  alert( 'Доступ разрешен' );
} else {
  alert( 'В доступе отказано' );
}
```
Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции.

Например:
```
function showMovie(age) {
  if (!checkAge(age)) {
    return;
  }

  alert( "Фильм не для всех" ); // (*)
  // ...
}
```
В коде выше, если сработал if, то строка (*) и весь код под ней никогда не выполнится, так как return завершает выполнение функции.

Значение функции без return и с пустым return
----------------------------------------------
В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
```
function doNothing() { /* пусто */ }

alert( doNothing() ); // undefined
```
Обратите внимание, никакой ошибки нет. Просто возвращается undefined.

Ещё пример, на этот раз с return без аргумента:
```
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```
Выбор имени функции
-------------------
Имя функции следует тем же правилам, что и имя переменной. Основное отличие — оно должно быть глаголом, т.к. функция — это действие.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение.

Функции, которые начинаются с "show" — что-то показывают:
```
showMessage(..)     // префикс show, "показать" сообщение
```
Функции, начинающиеся с "get" — получают, и т.п.:
```
getAge(..)          // get, "получает" возраст
calcD(..)           // calc, "вычисляет" дискриминант
createForm(..)      // create, "создает" форму
checkPermission(..) // check, "проверяет" разрешение, возвращает true/false
```
Это очень удобно, поскольку взглянув на функцию — мы уже примерно представляем, что она делает, даже если функцию написал совсем другой человек, а в отдельных случаях — и какого вида значение она возвращает.

Одна функция — одно действие
----------------------------
Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие.

Если оно сложное и подразумевает поддействия — может быть имеет смысл выделить их в отдельные функции? Зачастую это имеет смысл, чтобы лучше структурировать код.

…Но самое главное — в функции не должно быть ничего, кроме самого действия и поддействий, неразрывно связанных с ним.

Например, функция проверки данных (скажем, "validate") не должна показывать сообщение об ошибке. Её действие — проверить.

Сверхкороткие имена функций
---------------------------
Имена функций, которые используются очень часто, иногда делают сверхкороткими.
Например, во фреймворке jQuery есть функция $, во фреймворке Prototype — функция $$, а в библиотеке LoDash очень активно используется функция с названием из одного символа подчеркивания _.

Массивы c числовыми индексами
------------------------------
Массив — разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.

Они обычно используются для хранения упорядоченных коллекций данных, например — списка товаров на странице, студентов в группе и т.п.

Синтаксис для создания нового массива — квадратные скобки со списком элементов внутри.
--------------------------------------------------------------------------------------
Пустой массив:
--------------
```
var arr = [];
```
Массив fruits с тремя элементами:
```
var fruits = ["Яблоко", "Апельсин", "Слива"];
```
Элементы нумеруются, начиная с нуля.

Чтобы получить нужный элемент из массива — указывается его номер в квадратных скобках:
```
var fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
```
Элемент можно всегда заменить:
------------------------------
```
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
```
…Или добавить:
--------------
```
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
```
Общее число элементов, хранимых в массиве, содержится в его свойстве length:
----------------------------------------------------------------------------
```
var fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.length ); // 3
```
Через alert можно вывести и массив целиком.

При этом его элементы будут перечислены через запятую:
```
var fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits ); // Яблоко,Апельсин,Груша
```
В массиве может храниться любое число элементов любого типа.

В том числе, строки, числа, объекты, вот например:
```
// микс значений
var arr = [ 1, 'Имя', { name: 'Петя' }, true ];

// получить объект из массива и тут же -- его свойство
alert( arr[2].name ); // Петя
```
Методы pop/push, shift/unshift
-------------------------------
Одно из применений массива — это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются — с начала.

В реальной жизни эта структура данных встречается очень часто. Например, очередь сообщений, которые надо показать на экране.

Очень близка к очереди еще одна структура данных: стек. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца.

Например, стеком является колода карт, в которую новые карты кладутся сверху, и берутся — тоже сверху.

Для того, чтобы реализовывать эти структуры данных, и просто для более удобной работы с началом и концом массива существуют специальные методы.

Конец массива
-------------
pop
----
Удаляет последний элемент из массива и возвращает его:
```
var fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удалили "Груша"

alert( fruits ); // Яблоко, Апельсин
```
push
----
Добавляет элемент в конец массива:
```
var fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша
```
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

Начало массива
---------------
shift
-----
Удаляет из массива первый элемент и возвращает его:
```
var fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удалили Яблоко

alert( fruits ); // Апельсин, Груша
```
unshift
-------
Добавляет элемент в начало массива:
```
var fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша
```
Методы push и unshift могут добавлять сразу по несколько элементов:
```
var fruits = ["Яблоко"];

fruits.push("Апельсин", "Персик");
fruits.unshift("Ананас", "Лимон");

// результат: ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]
alert( fruits );
```
Внутреннее устройство массива
------------------------------
Массив — это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.

Так как это объект, то в функцию он передаётся по ссылке:
```
function eat(arr) {
  arr.pop();
}

var arr = ["нам", "не", "страшен", "серый", "волк"]

alert( arr.length ); // 5
eat(arr);
eat(arr);
alert( arr.length ); // 3, в функцию массив не скопирован, а передана ссылка
```
Ещё одно следствие — можно присваивать в массив любые свойства.
----------------------------------------------------------------
Например:
```
var fruits = []; // создать массив

fruits[99999] = 5; // присвоить свойство с любым номером

fruits.age = 25; // назначить свойство со строковым именем
```
.. Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно с упорядоченными, нумерованными данными. Для этого в них существуют специальные методы и свойство length.

Как правило, нет причин использовать массив как обычный объект, хотя технически это и возможно.

Вывод массива с «дырами»
-------------------------
Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые, например:
```
var a = [];
a[0] = 0;
a[5] = 5;

alert( a ); // 0,,,,,5
```
Эти запятые появляются потому, что алгоритм вывода массива идёт от 0 до arr.length и выводит всё через запятую. Отсутствие значений даёт несколько запятых подряд.

Влияние на быстродействие
-------------------------
Методы push/pop выполняются быстро, а shift/unshift — медленно.

Чтобы понять, почему работать с концом массива — быстрее, чем с его началом, разберём подробнее происходящее при операции:
```
fruits.shift(); // убрать 1 элемент с начала
```
При этом, так как все элементы находятся в своих ячейках, просто удалить элемент с номером 0 недостаточно. Нужно еще и переместить остальные элементы на их новые индексы.

Операция shift должна выполнить целых три действия:
---------------------------------------------------
- Удалить нулевой элемент.
- Переместить все свойства влево, с индекса 1 на 0, с 2 на 1 и так далее.
- Обновить свойство length.

Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью.

Аналогично работает unshift: чтобы добавить элемент в начало массива, нужно сначала перенести вправо, в увеличенные индексы, все существующие.

А что же с push/pop? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод pop очищает ячейку и укорачивает length.

Действия при операции:
----------------------
```
fruits.pop(); // убрать 1 элемент с конца
```

Перемещать при pop не требуется, так как прочие элементы после этой операции остаются на тех же индексах.

Аналогично работает push.

Перебор элементов
-----------------
Для перебора элементов обычно используется цикл:

```
var arr = ["Яблоко", "Апельсин", "Груша"];

for (var i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```
Не используйте for..in для массивов
-----------------------------------
Так как массив является объектом, то возможен и вариант for..in:
```
var arr = ["Яблоко", "Апельсин", "Груша"];

for (var key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
```
Недостатки этого способа:
-------------------------
Цикл for..in выведет все свойства объекта, а не только цифровые.
В браузере, при работе с объектами страницы, встречаются коллекции элементов, которые по виду как массивы, но имеют дополнительные нецифровые свойства. При переборе таких «похожих на массив» коллекций через for..in эти свойства будут выведены, а они как раз не нужны.

Бывают и библиотеки, которые предоставляют такие коллекции. Классический for надёжно выведет только цифровые свойства, что обычно и требуется.

Цикл 
```
for (var i=0; i<arr.length; i++) 
```
в современных браузерах выполняется в 10-100 раз быстрее. Казалось бы, по виду он сложнее, но браузер особым образом оптимизирует такие циклы.

Особенности работы length
-------------------------
Встроенные методы для работы с массивом автоматически обновляют его длину length.

Длина length — не количество элементов массива, а последний индекс + 1.

Это легко увидеть на следующем примере:
```
var arr = [];
arr[1000] = true;

alert(arr.length); // 1001
```
Кстати, если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.

Используем length для укорачивания массива
------------------------------------------
Обычно нам не нужно самостоятельно менять length… Но есть один фокус, который можно провернуть.

При уменьшении length массив укорачивается.

Причем этот процесс необратимый, т.е. даже если потом вернуть length обратно — значения не восстановятся:
```
var arr = [1, 2, 3, 4, 5];

arr.length = 2; // укоротить до 2 элементов
alert( arr ); // [1, 2]

arr.length = 5; // вернуть length обратно, как было
alert( arr[3] ); // undefined: значения не вернулись
```
Самый простой способ очистить массив — это arr.length=0.
--------------------------------------------------------
Создание вызовом new Array
---------------------------
```
new Array()
```
Существует еще один синтаксис для создания массива:
```
var arr = new Array("Яблоко", "Груша", "и т.п.");
```
Он редко используется, т.к. квадратные скобки [] короче.

Кроме того, у него есть одна особенность. Обычно new Array(элементы, ...) создаёт массив из данных элементов, но если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной.

Проверим это:
```
var arr = new Array(2, 3);
alert( arr[0] ); // 2, создан массив [2, 3], всё ок

arr = new Array(2); // создаст массив [2] ?
alert( arr[0] ); // undefined! у нас массив без элементов, длины 2
```
Что же такое этот «массив без элементов, но с длиной»? Как такое возможно?

Оказывается, очень даже возможно и соответствует объекту {length: 2}. Получившийся массив ведёт себя так, как будто его элементы равны undefined.

Это может быть неожиданным сюрпризом, поэтому обычно используют квадратные скобки.

Многомерные массивы
--------------------
Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:
```
var matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // центральный элемент
```

Массивы существуют для работы с упорядоченным набором элементов.
----------------------------------------------------------------
Объявление:
------------
```
// предпочтительное
var arr = [элемент1, элемент2...];

// new Array
var arr = new Array(элемент1, элемент2...);
```
При этом new Array(число) создаёт массив заданной длины, без элементов. Чтобы избежать ошибок, предпочтителен первый синтаксис.

Свойство length — длина массива. 
--------------------------------
Если точнее, то последний индекс массива плюс 1. Если её уменьшить вручную, то массив укоротится. Если length больше реального количества элементов, то отсутствующие элементы равны undefined.

Массив можно использовать как очередь или стек.
-----------------------------------------------
Операции с концом массива:
--------------------------
```
arr.push(элемент1, элемент2...) добавляет элементы в конец.
var elem = arr.pop() удаляет и возвращает последний элемент.
```
Операции с началом массива:
---------------------------
```
arr.unshift(элемент1, элемент2...) добавляет элементы в начало.
var elem = arr.shift() удаляет и возвращает первый элемент.
```
Эти операции перенумеровывают все элементы, поэтому работают медленно.

